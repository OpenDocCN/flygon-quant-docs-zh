["```py\n`self.sma = SimpleMovingAverage(.....)` \n```", "```py\n`av = self.sma[0]` \n```", "```py\n`previous_value = self.sma[-1]` \n```", "```py\n`from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport backtrader as bt\n\nif __name__ == '__main__':\n    cerebro = bt.Cerebro()\n\n    print('Starting Portfolio Value: %.2f' % cerebro.broker.getvalue())\n\n    cerebro.run()\n\n    print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())` \n```", "```py\n`Starting Portfolio Value: 10000.00\nFinal Portfolio Value: 10000.00` \n```", "```py\n`from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport backtrader as bt\n\nif __name__ == '__main__':\n    cerebro = bt.Cerebro()\n    cerebro.broker.setcash(100000.0)\n\n    print('Starting Portfolio Value: %.2f' % cerebro.broker.getvalue())\n\n    cerebro.run()\n\n    print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())` \n```", "```py\n`Starting Portfolio Value: 1000000.00\nFinal Portfolio Value: 1000000.00` \n```", "```py\n`from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport datetime  # For datetime objects\nimport os.path  # To manage paths\nimport sys  # To find out the script name (in argv[0])\n\n# Import the backtrader platform\nimport backtrader as bt\n\nif __name__ == '__main__':\n    # Create a cerebro entity\n    cerebro = bt.Cerebro()\n\n    # Datas are in a subfolder of the samples. Need to find where the script is\n    # because it could have been called from anywhere\n    modpath = os.path.dirname(os.path.abspath(sys.argv[0]))\n    datapath = os.path.join(modpath, '../../datas/orcl-1995-2014.txt')\n\n    # Create a Data Feed\n    data = bt.feeds.YahooFinanceCSVData(\n        dataname=datapath,\n        # Do not pass values before this date\n        fromdate=datetime.datetime(2000, 1, 1),\n        # Do not pass values after this date\n        todate=datetime.datetime(2000, 12, 31),\n        reverse=False)\n\n    # Add the Data Feed to Cerebro\n    cerebro.adddata(data)\n\n    # Set our desired cash start\n    cerebro.broker.setcash(100000.0)\n\n    # Print out the starting conditions\n    print('Starting Portfolio Value: %.2f' % cerebro.broker.getvalue())\n\n    # Run over everything\n    cerebro.run()\n\n    # Print out the final result\n    print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())` \n```", "```py\n`Starting Portfolio Value: 1000000.00\nFinal Portfolio Value: 1000000.00` \n```", "```py\n`from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport datetime  # For datetime objects\nimport os.path  # To manage paths\nimport sys  # To find out the script name (in argv[0])\n\n# Import the backtrader platform\nimport backtrader as bt\n\n# Create a Stratey\nclass TestStrategy(bt.Strategy):\n\n    def log(self, txt, dt=None):\n  ''' Logging function for this strategy'''\n        dt = dt or self.datas[0].datetime.date(0)\n        print('%s, %s' % (dt.isoformat(), txt))\n\n    def __init__(self):\n        # Keep a reference to the \"close\" line in the data[0] dataseries\n        self.dataclose = self.datas[0].close\n\n    def next(self):\n        # Simply log the closing price of the series from the reference\n        self.log('Close, %.2f' % self.dataclose[0])\n\nif __name__ == '__main__':\n    # Create a cerebro entity\n    cerebro = bt.Cerebro()\n\n    # Add a strategy\n    cerebro.addstrategy(TestStrategy)\n\n    # Datas are in a subfolder of the samples. Need to find where the script is\n    # because it could have been called from anywhere\n    modpath = os.path.dirname(os.path.abspath(sys.argv[0]))\n    datapath = os.path.join(modpath, '../../datas/orcl-1995-2014.txt')\n\n    # Create a Data Feed\n    data = bt.feeds.YahooFinanceCSVData(\n        dataname=datapath,\n        # Do not pass values before this date\n        fromdate=datetime.datetime(2000, 1, 1),\n        # Do not pass values before this date\n        todate=datetime.datetime(2000, 12, 31),\n        # Do not pass values after this date\n        reverse=False)\n\n    # Add the Data Feed to Cerebro\n    cerebro.adddata(data)\n\n    # Set our desired cash start\n    cerebro.broker.setcash(100000.0)\n\n    # Print out the starting conditions\n    print('Starting Portfolio Value: %.2f' % cerebro.broker.getvalue())\n\n    # Run over everything\n    cerebro.run()\n\n    # Print out the final result\n    print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())` \n```", "```py\n`Starting Portfolio Value: 100000.00\n2000-01-03T00:00:00, Close, 27.85\n2000-01-04T00:00:00, Close, 25.39\n2000-01-05T00:00:00, Close, 24.05\n...\n...\n...\n2000-12-26T00:00:00, Close, 29.17\n2000-12-27T00:00:00, Close, 28.94\n2000-12-28T00:00:00, Close, 29.29\n2000-12-29T00:00:00, Close, 27.41\nFinal Portfolio Value: 100000.00` \n```", "```py\n`from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport datetime  # For datetime objects\nimport os.path  # To manage paths\nimport sys  # To find out the script name (in argv[0])\n\n# Import the backtrader platform\nimport backtrader as bt\n\n# Create a Stratey\nclass TestStrategy(bt.Strategy):\n\n    def log(self, txt, dt=None):\n  ''' Logging function fot this strategy'''\n        dt = dt or self.datas[0].datetime.date(0)\n        print('%s, %s' % (dt.isoformat(), txt))\n\n    def __init__(self):\n        # Keep a reference to the \"close\" line in the data[0] dataseries\n        self.dataclose = self.datas[0].close\n\n    def next(self):\n        # Simply log the closing price of the series from the reference\n        self.log('Close, %.2f' % self.dataclose[0])\n\n        if self.dataclose[0] < self.dataclose[-1]:\n            # current close less than previous close\n\n            if self.dataclose[-1] < self.dataclose[-2]:\n                # previous close less than the previous close\n\n                # BUY, BUY, BUY!!! (with all possible default parameters)\n                self.log('BUY CREATE, %.2f' % self.dataclose[0])\n                self.buy()\n\nif __name__ == '__main__':\n    # Create a cerebro entity\n    cerebro = bt.Cerebro()\n\n    # Add a strategy\n    cerebro.addstrategy(TestStrategy)\n\n    # Datas are in a subfolder of the samples. Need to find where the script is\n    # because it could have been called from anywhere\n    modpath = os.path.dirname(os.path.abspath(sys.argv[0]))\n    datapath = os.path.join(modpath, '../../datas/orcl-1995-2014.txt')\n\n    # Create a Data Feed\n    data = bt.feeds.YahooFinanceCSVData(\n        dataname=datapath,\n        # Do not pass values before this date\n        fromdate=datetime.datetime(2000, 1, 1),\n        # Do not pass values before this date\n        todate=datetime.datetime(2000, 12, 31),\n        # Do not pass values after this date\n        reverse=False)\n\n    # Add the Data Feed to Cerebro\n    cerebro.adddata(data)\n\n    # Set our desired cash start\n    cerebro.broker.setcash(100000.0)\n\n    # Print out the starting conditions\n    print('Starting Portfolio Value: %.2f' % cerebro.broker.getvalue())\n\n    # Run over everything\n    cerebro.run()\n\n    # Print out the final result\n    print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())` \n```", "```py\n`Starting Portfolio Value: 100000.00\n2000-01-03, Close, 27.85\n2000-01-04, Close, 25.39\n2000-01-05, Close, 24.05\n2000-01-05, BUY CREATE, 24.05\n2000-01-06, Close, 22.63\n2000-01-06, BUY CREATE, 22.63\n2000-01-07, Close, 24.37\n...\n...\n...\n2000-12-20, BUY CREATE, 26.88\n2000-12-21, Close, 27.82\n2000-12-22, Close, 30.06\n2000-12-26, Close, 29.17\n2000-12-27, Close, 28.94\n2000-12-27, BUY CREATE, 28.94\n2000-12-28, Close, 29.29\n2000-12-29, Close, 27.41\nFinal Portfolio Value: 99725.08` \n```", "```py\n`from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport datetime  # For datetime objects\nimport os.path  # To manage paths\nimport sys  # To find out the script name (in argv[0])\n\n# Import the backtrader platform\nimport backtrader as bt\n\n# Create a Stratey\nclass TestStrategy(bt.Strategy):\n\n    def log(self, txt, dt=None):\n  ''' Logging function fot this strategy'''\n        dt = dt or self.datas[0].datetime.date(0)\n        print('%s, %s' % (dt.isoformat(), txt))\n\n    def __init__(self):\n        # Keep a reference to the \"close\" line in the data[0] dataseries\n        self.dataclose = self.datas[0].close\n\n        # To keep track of pending orders\n        self.order = None\n\n    def notify_order(self, order):\n        if order.status in [order.Submitted, order.Accepted]:\n            # Buy/Sell order submitted/accepted to/by broker - Nothing to do\n            return\n\n        # Check if an order has been completed\n        # Attention: broker could reject order if not enough cash\n        if order.status in [order.Completed]:\n            if order.isbuy():\n                self.log('BUY EXECUTED, %.2f' % order.executed.price)\n            elif order.issell():\n                self.log('SELL EXECUTED, %.2f' % order.executed.price)\n\n            self.bar_executed = len(self)\n\n        elif order.status in [order.Canceled, order.Margin, order.Rejected]:\n            self.log('Order Canceled/Margin/Rejected')\n\n        # Write down: no pending order\n        self.order = None\n\n    def next(self):\n        # Simply log the closing price of the series from the reference\n        self.log('Close, %.2f' % self.dataclose[0])\n\n        # Check if an order is pending ... if yes, we cannot send a 2nd one\n        if self.order:\n            return\n\n        # Check if we are in the market\n        if not self.position:\n\n            # Not yet ... we MIGHT BUY if ...\n            if self.dataclose[0] < self.dataclose[-1]:\n                    # current close less than previous close\n\n                    if self.dataclose[-1] < self.dataclose[-2]:\n                        # previous close less than the previous close\n\n                        # BUY, BUY, BUY!!! (with default parameters)\n                        self.log('BUY CREATE, %.2f' % self.dataclose[0])\n\n                        # Keep track of the created order to avoid a 2nd order\n                        self.order = self.buy()\n\n        else:\n\n            # Already in the market ... we might sell\n            if len(self) >= (self.bar_executed + 5):\n                # SELL, SELL, SELL!!! (with all possible default parameters)\n                self.log('SELL CREATE, %.2f' % self.dataclose[0])\n\n                # Keep track of the created order to avoid a 2nd order\n                self.order = self.sell()\n\nif __name__ == '__main__':\n    # Create a cerebro entity\n    cerebro = bt.Cerebro()\n\n    # Add a strategy\n    cerebro.addstrategy(TestStrategy)\n\n    # Datas are in a subfolder of the samples. Need to find where the script is\n    # because it could have been called from anywhere\n    modpath = os.path.dirname(os.path.abspath(sys.argv[0]))\n    datapath = os.path.join(modpath, '../../datas/orcl-1995-2014.txt')\n\n    # Create a Data Feed\n    data = bt.feeds.YahooFinanceCSVData(\n        dataname=datapath,\n        # Do not pass values before this date\n        fromdate=datetime.datetime(2000, 1, 1),\n        # Do not pass values before this date\n        todate=datetime.datetime(2000, 12, 31),\n        # Do not pass values after this date\n        reverse=False)\n\n    # Add the Data Feed to Cerebro\n    cerebro.adddata(data)\n\n    # Set our desired cash start\n    cerebro.broker.setcash(100000.0)\n\n    # Print out the starting conditions\n    print('Starting Portfolio Value: %.2f' % cerebro.broker.getvalue())\n\n    # Run over everything\n    cerebro.run()\n\n    # Print out the final result\n    print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())` \n```", "```py\n`Starting Portfolio Value: 100000.00\n2000-01-03T00:00:00, Close, 27.85\n2000-01-04T00:00:00, Close, 25.39\n2000-01-05T00:00:00, Close, 24.05\n2000-01-05T00:00:00, BUY CREATE, 24.05\n2000-01-06T00:00:00, BUY EXECUTED, 23.61\n2000-01-06T00:00:00, Close, 22.63\n2000-01-07T00:00:00, Close, 24.37\n2000-01-10T00:00:00, Close, 27.29\n2000-01-11T00:00:00, Close, 26.49\n2000-01-12T00:00:00, Close, 24.90\n2000-01-13T00:00:00, Close, 24.77\n2000-01-13T00:00:00, SELL CREATE, 24.77\n2000-01-14T00:00:00, SELL EXECUTED, 25.70\n2000-01-14T00:00:00, Close, 25.18\n...\n...\n...\n2000-12-15T00:00:00, SELL CREATE, 26.93\n2000-12-18T00:00:00, SELL EXECUTED, 28.29\n2000-12-18T00:00:00, Close, 30.18\n2000-12-19T00:00:00, Close, 28.88\n2000-12-20T00:00:00, Close, 26.88\n2000-12-20T00:00:00, BUY CREATE, 26.88\n2000-12-21T00:00:00, BUY EXECUTED, 26.23\n2000-12-21T00:00:00, Close, 27.82\n2000-12-22T00:00:00, Close, 30.06\n2000-12-26T00:00:00, Close, 29.17\n2000-12-27T00:00:00, Close, 28.94\n2000-12-28T00:00:00, Close, 29.29\n2000-12-29T00:00:00, Close, 27.41\n2000-12-29T00:00:00, SELL CREATE, 27.41\nFinal Portfolio Value: 100018.53` \n```", "```py\n`# 0.1% ... divide by 100 to remove the %\ncerebro.broker.setcommission(commission=0.001)` \n```", "```py\n`from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport datetime  # For datetime objects\nimport os.path  # To manage paths\nimport sys  # To find out the script name (in argv[0])\n\n# Import the backtrader platform\nimport backtrader as bt\n\n# Create a Stratey\nclass TestStrategy(bt.Strategy):\n\n    def log(self, txt, dt=None):\n  ''' Logging function fot this strategy'''\n        dt = dt or self.datas[0].datetime.date(0)\n        print('%s, %s' % (dt.isoformat(), txt))\n\n    def __init__(self):\n        # Keep a reference to the \"close\" line in the data[0] dataseries\n        self.dataclose = self.datas[0].close\n\n        # To keep track of pending orders and buy price/commission\n        self.order = None\n        self.buyprice = None\n        self.buycomm = None\n\n    def notify_order(self, order):\n        if order.status in [order.Submitted, order.Accepted]:\n            # Buy/Sell order submitted/accepted to/by broker - Nothing to do\n            return\n\n        # Check if an order has been completed\n        # Attention: broker could reject order if not enough cash\n        if order.status in [order.Completed]:\n            if order.isbuy():\n                self.log(\n                    'BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f' %\n                    (order.executed.price,\n                     order.executed.value,\n                     order.executed.comm))\n\n                self.buyprice = order.executed.price\n                self.buycomm = order.executed.comm\n            else:  # Sell\n                self.log('SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f' %\n                         (order.executed.price,\n                          order.executed.value,\n                          order.executed.comm))\n\n            self.bar_executed = len(self)\n\n        elif order.status in [order.Canceled, order.Margin, order.Rejected]:\n            self.log('Order Canceled/Margin/Rejected')\n\n        self.order = None\n\n    def notify_trade(self, trade):\n        if not trade.isclosed:\n            return\n\n        self.log('OPERATION PROFIT, GROSS %.2f, NET %.2f' %\n                 (trade.pnl, trade.pnlcomm))\n\n    def next(self):\n        # Simply log the closing price of the series from the reference\n        self.log('Close, %.2f' % self.dataclose[0])\n\n        # Check if an order is pending ... if yes, we cannot send a 2nd one\n        if self.order:\n            return\n\n        # Check if we are in the market\n        if not self.position:\n\n            # Not yet ... we MIGHT BUY if ...\n            if self.dataclose[0] < self.dataclose[-1]:\n                    # current close less than previous close\n\n                    if self.dataclose[-1] < self.dataclose[-2]:\n                        # previous close less than the previous close\n\n                        # BUY, BUY, BUY!!! (with default parameters)\n                        self.log('BUY CREATE, %.2f' % self.dataclose[0])\n\n                        # Keep track of the created order to avoid a 2nd order\n                        self.order = self.buy()\n\n        else:\n\n            # Already in the market ... we might sell\n            if len(self) >= (self.bar_executed + 5):\n                # SELL, SELL, SELL!!! (with all possible default parameters)\n                self.log('SELL CREATE, %.2f' % self.dataclose[0])\n\n                # Keep track of the created order to avoid a 2nd order\n                self.order = self.sell()\n\nif __name__ == '__main__':\n    # Create a cerebro entity\n    cerebro = bt.Cerebro()\n\n    # Add a strategy\n    cerebro.addstrategy(TestStrategy)\n\n    # Datas are in a subfolder of the samples. Need to find where the script is\n    # because it could have been called from anywhere\n    modpath = os.path.dirname(os.path.abspath(sys.argv[0]))\n    datapath = os.path.join(modpath, '../../datas/orcl-1995-2014.txt')\n\n    # Create a Data Feed\n    data = bt.feeds.YahooFinanceCSVData(\n        dataname=datapath,\n        # Do not pass values before this date\n        fromdate=datetime.datetime(2000, 1, 1),\n        # Do not pass values before this date\n        todate=datetime.datetime(2000, 12, 31),\n        # Do not pass values after this date\n        reverse=False)\n\n    # Add the Data Feed to Cerebro\n    cerebro.adddata(data)\n\n    # Set our desired cash start\n    cerebro.broker.setcash(100000.0)\n\n    # Set the commission - 0.1% ... divide by 100 to remove the %\n    cerebro.broker.setcommission(commission=0.001)\n\n    # Print out the starting conditions\n    print('Starting Portfolio Value: %.2f' % cerebro.broker.getvalue())\n\n    # Run over everything\n    cerebro.run()\n\n    # Print out the final result\n    print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())` \n```", "```py\n`Starting Portfolio Value: 100000.00\n2000-01-03T00:00:00, Close, 27.85\n2000-01-04T00:00:00, Close, 25.39\n2000-01-05T00:00:00, Close, 24.05\n2000-01-05T00:00:00, BUY CREATE, 24.05\n2000-01-06T00:00:00, BUY EXECUTED, Price: 23.61, Cost: 23.61, Commission 0.02\n2000-01-06T00:00:00, Close, 22.63\n2000-01-07T00:00:00, Close, 24.37\n2000-01-10T00:00:00, Close, 27.29\n2000-01-11T00:00:00, Close, 26.49\n2000-01-12T00:00:00, Close, 24.90\n2000-01-13T00:00:00, Close, 24.77\n2000-01-13T00:00:00, SELL CREATE, 24.77\n2000-01-14T00:00:00, SELL EXECUTED, Price: 25.70, Cost: 25.70, Commission 0.03\n2000-01-14T00:00:00, OPERATION PROFIT, GROSS 2.09, NET 2.04\n2000-01-14T00:00:00, Close, 25.18\n...\n...\n...\n2000-12-15T00:00:00, SELL CREATE, 26.93\n2000-12-18T00:00:00, SELL EXECUTED, Price: 28.29, Cost: 28.29, Commission 0.03\n2000-12-18T00:00:00, OPERATION PROFIT, GROSS -0.06, NET -0.12\n2000-12-18T00:00:00, Close, 30.18\n2000-12-19T00:00:00, Close, 28.88\n2000-12-20T00:00:00, Close, 26.88\n2000-12-20T00:00:00, BUY CREATE, 26.88\n2000-12-21T00:00:00, BUY EXECUTED, Price: 26.23, Cost: 26.23, Commission 0.03\n2000-12-21T00:00:00, Close, 27.82\n2000-12-22T00:00:00, Close, 30.06\n2000-12-26T00:00:00, Close, 29.17\n2000-12-27T00:00:00, Close, 28.94\n2000-12-28T00:00:00, Close, 29.29\n2000-12-29T00:00:00, Close, 27.41\n2000-12-29T00:00:00, SELL CREATE, 27.41\nFinal Portfolio Value: 100016.98` \n```", "```py\n`2000-01-14T00:00:00, OPERATION PROFIT, GROSS 2.09, NET 2.04\n2000-02-07T00:00:00, OPERATION PROFIT, GROSS 3.68, NET 3.63\n2000-02-28T00:00:00, OPERATION PROFIT, GROSS 4.48, NET 4.42\n2000-03-13T00:00:00, OPERATION PROFIT, GROSS 3.48, NET 3.41\n2000-03-22T00:00:00, OPERATION PROFIT, GROSS -0.41, NET -0.49\n2000-04-07T00:00:00, OPERATION PROFIT, GROSS 2.45, NET 2.37\n2000-04-20T00:00:00, OPERATION PROFIT, GROSS -1.95, NET -2.02\n2000-05-02T00:00:00, OPERATION PROFIT, GROSS 5.46, NET 5.39\n2000-05-11T00:00:00, OPERATION PROFIT, GROSS -3.74, NET -3.81\n2000-05-30T00:00:00, OPERATION PROFIT, GROSS -1.46, NET -1.53\n2000-07-05T00:00:00, OPERATION PROFIT, GROSS -1.62, NET -1.69\n2000-07-14T00:00:00, OPERATION PROFIT, GROSS 2.08, NET 2.01\n2000-07-28T00:00:00, OPERATION PROFIT, GROSS 0.14, NET 0.07\n2000-08-08T00:00:00, OPERATION PROFIT, GROSS 4.36, NET 4.29\n2000-08-21T00:00:00, OPERATION PROFIT, GROSS 1.03, NET 0.95\n2000-09-15T00:00:00, OPERATION PROFIT, GROSS -4.26, NET -4.34\n2000-09-27T00:00:00, OPERATION PROFIT, GROSS 1.29, NET 1.22\n2000-10-13T00:00:00, OPERATION PROFIT, GROSS -2.98, NET -3.04\n2000-10-26T00:00:00, OPERATION PROFIT, GROSS 3.01, NET 2.95\n2000-11-06T00:00:00, OPERATION PROFIT, GROSS -3.59, NET -3.65\n2000-11-16T00:00:00, OPERATION PROFIT, GROSS 1.28, NET 1.23\n2000-12-01T00:00:00, OPERATION PROFIT, GROSS 2.59, NET 2.54\n2000-12-18T00:00:00, OPERATION PROFIT, GROSS -0.06, NET -0.12` \n```", "```py\n`15.83` \n```", "```py\n`2000-12-29T00:00:00, SELL CREATE, 27.41\nFinal Portfolio Value: 100016.98` \n```", "```py\n`2001-01-02T00:00:00, SELL EXECUTED, Price: 27.87, Cost: 27.87, Commission 0.03\n2001-01-02T00:00:00, OPERATION PROFIT, GROSS 1.64, NET 1.59\n2001-01-02T00:00:00, Close, 24.87\n2001-01-02T00:00:00, BUY CREATE, 24.87\nFinal Portfolio Value: 100017.41` \n```", "```py\n`15.83 + 1.59 = 17.42` \n```", "```py\n`params = (('myparam', 27), ('exitbars', 5),)` \n```", "```py\n`params = (\n    ('myparam', 27),\n    ('exitbars', 5),\n)` \n```", "```py\n`# Add a strategy\ncerebro.addstrategy(TestStrategy, myparam=20, exitbars=7)` \n```", "```py\n`cerebro.addsizer(bt.sizers.FixedSize, stake=10)```", "```py\n\nPlease read the section about *sizers*\n\nUsing the parameters in the strategy is easy, as they are stored in a \u201cparams\u201d attribute. If we for example want to set the stake fix, we can pass the stake parameter to the *position sizer* like this durint **init**:\n\n```", "```py\n\nWe could have also called *buy* and *sell* with a *stake* parameter and *self.params.stake* as the value.\n\nThe logic to exit gets modified:\n\n```", "```py\n\nWith all this in mind the example evolves to look like:\n\n```", "```py\n\nAfter the execution the output is:\n\n```", "```py\n\nIn order to see the difference, the print outputs have also been extended to show the execution size.\n\nHaving multiplied the stake by 10, the obvious has happened: the profit and loss has been multiplied by 10\\. Instead of *16.98*, the surplus is now *169.80*\n\n### Adding an indicator\n\nHaving heard of *indicators*, the next thing anyone would add to the strategy is one of them. For sure they must be much better than a simple *\u201c3 lower closes\u201d* strategy.\n\nInspired in one of the examples from PyAlgoTrade a strategy using a Simple Moving Average.\n\n*   Buy \u201cAtMarket\u201d if the close is greater than the Average\n\n*   If in the market, sell if the close is smaller than the Average\n\n*   Only 1 active operation is allowed in the market\n\nMost of the existing code can be kept in place. Let\u2019s add the average during **init** and keep a reference to it:\n\n```", "```py\n\nAnd of course the logic to enter and exit the market will rely on the Average values. Look in the code for the logic.\n\nNote\n\nThe starting cash will be 1000 monetary units to be in line with the PyAlgoTrade example and no commission will be applied\n\n```", "```py\n\nNow, before skipping to the next section **LOOK CAREFULLY** to the first date which is shown in the log:\n\n*   It\u2019 no longer *2000-01-03*, the first trading day in the year 2K.\n\n    It\u2019s 2000-01-24 \u2026 *Who has stolen my cheese?*\n\nThe missing days are not missing. The platform has adapted to the new circumstances:\n\n*   An indicator (SimpleMovingAverage) has been added to the Strategy.\n\n*   This indicator needs X bars to produce an output: in the example: 15\n\n*   2000-01-24 is the day in which the 15^(th) bar occurs\n\nThe *backtrader* platform assumes that the Strategy has the indicator in place for a good reason, **to use it in the decision making process**. And it makes no sense to try to make decisions if the indicator is not yet ready and producing values.\n\n*   *next* will be 1^(st) called when all indicators have already reached the minimum needed period to produce a value\n\n*   In the example there is a single indicator, but the strategy could have any number of them.\n\nAfter the execution the output is:\n\n```", "```py\n\nIn the name of the King!!! A winning system turned into a losing one \u2026 and that with no commission. It may well be that **simply** adding an *indicator* is not the universal panacea.\n\nNote\n\nThe same logic and data with PyAlgoTrade yields a slightly different result (slightly off). Looking at the entire printout reveals that some operations are not exactly the same. Being the culprit again the usual suspect: *rounding*.\n\nPyAlgoTrade does not round the datafeed values when applying the divided \u201cadjusted close\u201d to the data feed values.\n\nThe Yahoo Data Feed provided by *backtrader* rounds the values down to 2 decimals after applying the adjusted close. Upon printing the values everything seems the same, but it\u2019s obvious that sometimes that 5^(th) place decimal plays a role.\n\nRounding down to 2 decimals seems more realistic, because Market Exchanges do only allow a number of decimals per asset (being that 2 decimals usually for stocks)\n\nNote\n\nThe Yahoo Data Feed (starting with version `1.8.11.99` allows to specify if rounding has to happen and how many decimals)\n\n### Visual Inspection: Plotting\n\nA printout or log of the actual whereabouts of the system at each bar-instant is good but humans tend to be *visual* and therefore it seems right to offer a view of the same whereabouts as chart.\n\nNote\n\nTo plot you need to have *matplotlib* installed\n\nOnce again defaults for plotting are there to assist the platform user. Plotting is incredibly a 1 line operation:\n\n```", "```py\n\nBeing the location for sure after cerebro.run() has been called.\n\nIn order to display the automatic plotting capabilities and a couple of easy customizations, the following will be done:\n\n*   A 2^(nd) MovingAverage (Exponential) will be added. The defaults will plot it (just like the 1^(st)) with the data.\n\n*   A 3^(rd) MovingAverage (Weighted) will be added. Customized to plot in an own plot (even if not sensible)\n\n*   A Stochastic (Slow) will be added. No change to the defaults.\n\n*   A MACD will be added. No change to the defaults.\n\n*   A RSI will be added. No change to the defaults.\n\n*   A MovingAverage (Simple) will be applied to the RSI. No change to the defaults (it will be plotted with the RSI)\n\n*   An AverageTrueRange will be added. Changed defaults to avoid it being plotted.\n\nThe entire set of additions to the **init** method of the Strategy:\n\n```", "```py\n\nNote\n\nEven if *indicators* are not explicitly added to a member variable of the strategy (like self.sma = MovingAverageSimple\u2026), they will autoregister with the strategy and will influence the minimum period for *next* and will be part of the plotting.\n\nIn the example only *RSI* is added to a temporary variable *rsi* with the only intention to create a MovingAverageSmoothed on it.\n\nThe example now:\n\n```", "```py\n\nAfter the execution the output is:\n\n```", "```py\n\n**The final result has changed even if the logic hasn\u2019t**. This is true but the logic has not been applied to the same number of bars.\n\nNote\n\nAs explained before, the platform will first call next when all indicators are ready to produce a value. In this plotting example (very clear in the chart) the MACD is the last indicator to be fully ready (all 3 lines producing an output). The 1^(st) BUY order is no longer scheduled during Jan 2000 but close to the end of Feb 2000.\n\nThe chart:\n\n![image](../Images/ea78429a6e60755c2d70c3857cb63606.png)\n\n### Let\u2019s Optimize\n\nMany trading books say each market and each traded stock (or commodity or ..) have different rythms. That there is no such thing as a one size fits all.\n\nBefore the plotting sample, when the strategy started using an indicator the period default value was 15 bars. It\u2019s a strategy parameter and this can be used in an optimization to change the value of the parameter and see which one better fits the market.\n\nNote\n\nThere is plenty of literature about Optimization and associated pros and cons. But the advice will always point in the same direction: do not overoptimize. If a trading idea is not sound, optimizing may end producing a positive result which is only valid for the backtested dataset.\n\nThe sample is modified to optimize the period of the Simple Moving Average. For the sake of clarity any output with regards to Buy/Sell orders has been removed\n\nThe example now:\n\n```", "```py\n\nInstead of calling *addstrategy* to add a stratey class to Cerebro, the call is made to *optstrategy*. And instead of passing a value a range of values is passed.\n\nOne of the \u201cStrategy\u201d hooks is added, the *stop* method, which will be called when the data has been exhausted and backtesting is over. It\u2019s used to print the final net value of the portfolio in the broker (it was done in Cerebro previously)\n\nThe system will execute the strategy for each value of the range. The following will be output:\n\n```"]