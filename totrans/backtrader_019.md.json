["```py\n`import backtrader as bt\nimport backtrader.indicators as btind\nimport backtrader.feeds as btfeeds` \n```", "```py\n`import backtrader as bt` \n```", "```py\n`thefeed = bt.feeds.OneOfTheFeeds(...)\ntheind = bt.indicators.SimpleMovingAverage(...)` \n```", "```py\n`class MyStrategy(bt.Strategy):\n    params = dict(period=20)\n\n    def __init__(self):\n\n        sma = btind.SimpleMovingAverage(self.datas[0], period=self.params.period)\n\n    ...\n\ncerebro = bt.Cerebro()\n\n...\n\ndata = btfeeds.MyFeed(...)\ncerebro.adddata(data)\n\n...\n\ncerebro.addstrategy(MyStrategy, period=30)\n\n...` \n```", "```py\n`class MyStrategy(bt.Strategy):\n    params = dict(period=20)\n\n    def __init__(self):\n\n        sma = btind.SimpleMovingAverage(self.data, period=self.params.period)\n\n    ...` \n```", "```py\n`class MyStrategy(bt.Strategy):\n    params = dict(period=20)\n\n    def __init__(self):\n\n        sma = btind.SimpleMovingAverage(period=self.params.period)\n\n    ...` \n```", "```py\n`class MyStrategy(bt.Strategy):\n    params = dict(period1=20, period2=25, period3=10, period4)\n\n    def __init__(self):\n\n        sma1 = btind.SimpleMovingAverage(self.datas[0], period=self.p.period1)\n\n        # This 2nd Moving Average operates using sma1 as \"data\"\n        sma2 = btind.SimpleMovingAverage(sma1, period=self.p.period2)\n\n        # New data created via arithmetic operation\n        something = sma2 - sma1 + self.data.close\n\n        # This 3rd Moving Average operates using something  as \"data\"\n        sma3 = btind.SimpleMovingAverage(something, period=self.p.period3)\n\n        # Comparison operators work too ...\n        greater = sma3 > sma1\n\n        # Pointless Moving Average of True/False values but valid\n        # This 4th Moving Average operates using greater  as \"data\"\n        sma3 = btind.SimpleMovingAverage(greater, period=self.p.period4)\n\n    ...` \n```", "```py\n`class MyStrategy(bt.Strategy):\n    params = (('period', 20),)\n\n    def __init__(self):\n        sma = btind.SimpleMovingAverage(self.data, period=self.p.period)` \n```", "```py\n`class MyStrategy(bt.Strategy):\n    params = dict(period=20)\n\n    def __init__(self):\n        sma = btind.SimpleMovingAverage(self.data, period=self.p.period)` \n```", "```py\n`class MyStrategy(bt.Strategy):\n    params = dict(period=20)\n\n    def __init__(self):\n\n        self.movav = btind.SimpleMovingAverage(self.data, period=self.p.period)\n\n    def next(self):\n        if self.movav.lines.sma[0] > self.data.lines.close[0]:\n            print('Simple Moving Average is greater than the closing price')` \n```", "```py\n`class SimpleMovingAverage(Indicator):\n    lines = ('sma',)\n\n    ...` \n```", "```py\n`data = btfeeds.BacktraderCSVData(dataname='mydata.csv')\n\n...\n\nclass MyStrategy(bt.Strategy):\n\n    ...\n\n    def next(self):\n\n        if self.data.close[0] > 30.0:\n            ...` \n```", "```py\n`def next(self):\n    if self.movav.lines.sma[0] > self.data.lines.close[0]:\n        print('Simple Moving Average is greater than the closing price')` \n```", "```py\n`if self.movav.lines.sma > self.data.lines.close:\n    ...` \n```", "```py\n`def next(self):\n  self.line[0] = math.fsum(self.data.get(0, size=self.p.period)) / self.p.period` \n```", "```py\n`def next(self):\n    if self.data.close[0] > self.data.close[-1]:\n        print('Closing price is higher today')` \n```", "```py\n`myslice = self.my_sma[0:]  # slice from the beginning til the end` \n```", "```py\n`myslice = self.my_sma[0:-1]  # slice from the beginning til the end` \n```", "```py\n`myslice = self.my_sma[:0]  # slice from current point backwards to the beginning` \n```", "```py\n`myslice = self.my_sma[-1:0]  # last value and current value` \n```", "```py\n`myslice = self.my_sma[-3:-1]  # from last value backwards to the 3rd last value` \n```", "```py\n`myslice = self.my_sma.get(ago=0, size=1)  # default values shown` \n```", "```py\n`myslice = self.my_sma.get(size=10)  # ago defaults to 0` \n```", "```py\n`myslice = self.my_sma.get(ago=-1, size=10)` \n```", "```py\n`class MyStrategy(bt.Strategy):\n    params = dict(period=20)\n\n    def __init__(self):\n\n        self.movav = btind.SimpleMovingAverage(self.data, period=self.p.period)\n        self.cmpval = self.data.close(-1) > self.sma\n\n    def next(self):\n        if self.cmpval[0]:\n            print('Previous close is higher than the moving average')` \n```", "```py\n`class MyStrategy(bt.Strategy):\n    params = dict(period=20)\n\n    def __init__(self):\n\n        # data0 is a daily data\n        sma0 = btind.SMA(self.data0, period=15)  # 15 days sma\n        # data1 is a weekly data\n        sma1 = btind.SMA(self.data1, period=5)  # 5 weeks sma\n\n        self.buysig = sma0 > sma1()\n\n    def next(self):\n        if self.buysig[0]:\n            print('daily sma is greater than weekly sma1')` \n```", "```py\n`def __init__(self):\n    # Sum N period values - datasum is now a *Lines* object\n    # that when queried with the operator [] and index 0\n    # returns the current sum\n\n    datasum = btind.SumN(self.data, period=self.params.period)\n\n    # datasum (being *Lines* object although single line) can be\n    # naturally divided by an int/float as in this case. It could\n    # actually be divided by anothr *Lines* object.\n    # The operation returns an object assigned to \"av\" which again\n    # returns the current average at the current instant in time\n    # when queried with [0]\n\n    av = datasum / self.params.period\n\n    # The av *Lines* object can be naturally assigned to the named\n    # line this indicator delivers. Other objects using this\n    # indicator will have direct access to the calculation\n\n    self.line.sma = av` \n```", "```py\n`class MyStrategy(bt.Strategy):\n\n    def __init__(self):\n\n        sma = btind.SimpleMovinAverage(self.data, period=20)\n\n        close_over_sma = self.data.close > sma\n        sma_dist_to_high = self.data.high - sma\n\n        sma_dist_small = sma_dist_to_high < 3.5\n\n        # Unfortunately \"and\" cannot be overridden in Python being\n        # a language construct and not an operator and thus a\n        # function has to be provided by the platform to emulate it\n\n        sell_sig = bt.And(close_over_sma, sma_dist_small)` \n```", "```py\n`class MyStrategy(bt.Strategy):\n\n    def __init__(self):\n\n        self.sma = sma = btind.SimpleMovinAverage(self.data, period=20)\n\n        close_over_sma = self.data.close > sma\n        self.sma_dist_to_high = self.data.high - sma\n\n        sma_dist_small = sma_dist_to_high < 3.5\n\n        # Unfortunately \"and\" cannot be overridden in Python being\n        # a language construct and not an operator and thus a\n        # function has to be provided by the platform to emulate it\n\n        self.sell_sig = bt.And(close_over_sma, sma_dist_small)\n\n    def next(self):\n\n        # Although this does not seem like an \"operator\" it actually is\n        # in the sense that the object is being tested for a True/False\n        # response\n\n        if self.sma > 30.0:\n            print('sma is greater than 30.0')\n\n        if self.sma > self.data.close:\n            print('sma is above the close price')\n\n        if self.sell_sig:  # if sell_sig == True: would also be valid\n            print('sell sig is True')\n        else:\n            print('sell sig is False')\n\n        if self.sma_dist_to_high > 5.0:\n            print('distance from sma to hig is greater than 5.0')` \n```", "```py\n`class MyStrategy(bt.Strategy):\n\n    def __init__(self):\n\n        sma1 = btind.SMA(self.data.close, period=15)\n        self.buysig = bt.And(sma1 > self.data.close, sma1 > self.data.high)\n\n    def next(self):\n        if self.buysig[0]:\n            pass  # do something here` \n```", "```py\n`class MyStrategy(bt.Strategy):\n\n    def __init__(self):\n\n        sma1 = btind.SMA(self.data.close, period=15)\n        high_or_low = bt.If(sma1 > self.data.close, self.data.low, self.data.high)\n        sma2 = btind.SMA(high_or_low, period=15)` \n```", "```py\n`class MyStrategy(bt.Strategy):\n\n    def __init__(self):\n\n        sma1 = btind.SMA(self.data.close, period=15)\n        high_or_30 = bt.If(sma1 > self.data.close, 30.0, self.data.high)\n        sma2 = btind.SMA(high_or_30, period=15)` \n```"]