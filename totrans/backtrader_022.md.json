["```py\n    `cerebro = bt.Cerebro(**kwargs)` \n    ```", "```py\n    `data = bt.BacktraderCSVData(dataname='mypath.days', timeframe=bt.TimeFrame.Days)\n    cerebro.adddata(data)` \n    ```", "```py\n    `data = bt.BacktraderCSVData(dataname='mypath.min', timeframe=bt.TimeFrame.Minutes)\n    cerebro.resampledata(data, timeframe=bt.TimeFrame.Days)` \n    ```", "```py\n    `data = bt.BacktraderCSVData(dataname='mypath.min', timeframe=bt.TimeFrame.Minutes)\n    cerebro.replaydatadata(data, timeframe=bt.TimeFrame.Days)` \n    ```", "```py\n    `cerebro.addstrategy(MyStrategy, myparam1=value1, myparam2=value2)` \n    ```", "```py\n    `cerebro.optstrategy(MyStrategy, myparam1=range(10, 20))` \n    ```", "```py\n    `broker = MyBroker()\n    cerebro.broker = broker  # property using getbroker/setbroker methods` \n    ```", "```py\n    `callback(msg, *args, **kwargs)` \n    ```", "```py\n`result = cerebro.run(**kwargs)` \n```", "```py\n`result = cerebro.run(**kwargs)` \n```", "```py\n`cerebro.plot()` \n```", "```py\n     `* If the next tick to deliver is newer (datetime-wise) than the one\n       delivered by the `datamaster` it will not be delivered\n\n     * May return without delivering a new tick for a number of reasons` \n    ```", "```py\n`* `True` or `1`: all \u201clines\u201d objects reduce memory usage to the\n  automatically calculated minimum period.\n\n  If a Simple Moving Average has a period of 30, the underlying data\n  will have always a running buffer of 30 bars to allow the\n  calculation of the Simple Moving Average\n\n  * This setting will deactivate `preload` and `runonce`\n\n  * Using this setting also deactivates **plotting**\n\n* `-1`: datafreeds and indicators/operations at strategy level will\n  keep all data in memory.\n\n  For example: a `RSI` internally uses the indicator `UpDay` to\n  make calculations. This subindicator will not keep all data in\n  memory\n\n  * This allows to keep `plotting` and `preloading` active.\n\n  * `runonce` will be deactivated\n\n* `-2`: data feeds and indicators kept as attributes of the\n  strategy will keep all points in memory.\n\n  For example: a `RSI` internally uses the indicator `UpDay` to\n  make calculations. This subindicator will not keep all data in\n  memory\n\n  If in the `__init__` something like\n  `a = self.data.close - self.data.high` is defined, then `a`\n  will not keep all data in memory\n\n  * This allows to keep `plotting` and `preloading` active.\n\n  * `runonce` will be deactivated` \n```", "```py\n`bp = self.data.close - TrueLow(self.data)\ntr = TrueRange(self.data)  # -> creates another TrueLow(self.data)` \n```", "```py\n`* `params` (or `p`) the strategy had for the execution\n\n* `analyzers` the strategy has executed` \n```", "```py\n`* `None`: in this case the datetime displayed by strategies will be\n  in UTC, which has been always the standard behavior\n\n* `pytz` instance. It will be used as such to convert UTC times to\n  the chosen timezone\n\n* `string`. Instantiating a `pytz` instance will be attempted.\n\n* `integer`. Use, for the strategy, the same timezone as the\n  corresponding `data` in the `self.datas` iterable (`0` would\n  use the timezone from `data0`)` \n```"]