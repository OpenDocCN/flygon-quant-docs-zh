- en: Cerebro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.backtrader.com/docu/cerebro/](https://www.backtrader.com/docu/cerebro/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This class is the cornerstone of `backtrader` because it serves as a central
    point for:'
  prefs: []
  type: TYPE_NORMAL
- en: Gathering all inputs (*Data Feeds*), actors (*Stratgegies*), spectators (*Observers*),
    critics (*Analyzers*) and documenters (*Writers*) ensuring the show still goes
    on at any moment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the backtesting/or live data feeding/trading
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Returning the results
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Giving access to the plotting facilities
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gathering input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start by creating a `cerebro`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Some `**kwargs` to control execution are supported, see the reference (the same
    arguments can be applied later to the `run` method)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add *Data feeds*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The most usual pattern is `cerebro.adddata(data)`, where `data` is a *data
    feed* already instantiated. Example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Resampling* and *Replaying* a data is possible and follows the same pattern:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'or:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The system can accept any number of data feeds, including mixing regular data
    with resampled and/or replayed data. Of course some of this combinationns will
    for sure make no sense and a restriction apply in order to be able to combine
    datas: *time aligment*. See the Data - Multiple Timeframes, Data Resampling -
    Resampling` and Data - Replay sections.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add `Strategies`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Unlike the `datas feeds` which are already an instance of a class, `cerebro`
    takes directly the `Strategy` class and the arguments to pass to it. The rationale
    behind: *in an optimization scenario the class will be instantiated several times
    and passed different arguments*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Even if no *optimization* is run, the pattern still applies:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When *optimizing* the parameters have to be added as iterables. See the *Optimization*
    section for a detailed explanation. The basic pattern:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Which will run `MyStrategy` 10 times with `myparam1` taking values from 10 to
    19 (remember ranges in Python are half-open and `20` will not be reached)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Other elements
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are some other elements which can be added to enhance the backtesting
    experience. See the appropriate sections for it. The methods are:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`addwriter`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addanalyzer`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addobserver` (or `addobservermulti`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the broker
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Cerebro will use the default broker in `backtrader`, but this can be overriden:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Receive notifications
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If *data feeds* and/or *brokers* send notifications (or a *store* provider which
    creates them) they will be received through the `Cerebro.notify_store` method.
    There are three (3) ways to work with these notifications
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a *callback* to a `cerebro` instance via the `addnotifycallback(callback)`
    call. The callback has to support this signature:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The actual `msg`, `*args` and `**kwargs` received are implementation defined
    (depend entirely on the *data/broker/store*) but in general one should expect
    them to be *printable* to allow for reception and experimentation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Override the `notify_store` method in the `Strategy` subclass which is added
    to a `cerebro` instance.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The signature: `notify_store(self, msg, *args, **kwargs)`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Subclass `Cerebro` and override `notify_store` (same signature as in the `Strategy`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This should be the least preferred method
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Execute the backtesting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a single method to do it, but it supports several options (which can
    be also specified when instantiating) to decide how to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: See the reerence below to understand which arguments are available.
  prefs: []
  type: TYPE_NORMAL
- en: Standard Observers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`cerebro` (unless otherwise specified) automatically instantiates *three* standard
    observers'
  prefs: []
  type: TYPE_NORMAL
- en: A *Broker* observer which keeps track of `cash` and `value` (portfolio)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *Trades* observer which should show how effective each trade has been
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *Buy/Sell* observer which should document when operations are executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should a cleaner plotting be wished just disable them with `stdstats=False`
  prefs: []
  type: TYPE_NORMAL
- en: Returning the results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`cerebro` returns the instances of the strategies it created during backtesting.
    This allows to analyze what they did, because all elements in the strategies are
    accessible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The format of `result` returned by `run` will vary depending on whether *optimization*
    is used (a *strategy* was added with `optstrategy`):'
  prefs: []
  type: TYPE_NORMAL
- en: All strategies added with `addstrategy`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`result` will be a `list` of the instances run during the backtesting'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1 or more strategies were added with `optstrategy`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`result` will be a `list` of `list`. Each internal list will contain the strategies
    after each optimization run'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The default behavior for *optimization* was changed to only return the *analyzers*
    present in the system, to make message passing across computer cores lighter.
  prefs: []
  type: TYPE_NORMAL
- en: If the complete set of strategies is wished as return value, set the parameter
    `optreturn` to `False`
  prefs: []
  type: TYPE_NORMAL
- en: Giving access to the plotting facilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an extra an if `matplotlib` is installed, the strategies can be plotted.
    With the usual pattern being:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: See below for the reference and the section Plotting
  prefs: []
  type: TYPE_NORMAL
- en: Backtesting logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Brief outline of the flow of things:'
  prefs: []
  type: TYPE_NORMAL
- en: Deliver any store notifications
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ask data feeds to deliver the next set of ticks/bars
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Versionchanged:** Changed in version 1.9.0.99: *New Behavior*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Data Feeds are synchronized by peeking at the *datetime* which is going to be
    provided next by available data feeds. Feeds which have not traded in the new
    period still provide the old data points, whilst data feeds which have new data
    available offer this one (along with the calculation of indicators)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Old Behavior* (retained when using `oldsync=True` with *Cerebro*)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The 1^(st) data inserted into the system is the `datamaster` and the system
    will wait for it to deliver a tick
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The other data feeds are, more or less, slaves to the `datamaster` and:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The logic was designed to easily synchronize multiple data feeds and data feeds
    with different timeframes
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notify the strategy about queued broker notifications of orders, trades and
    cash/value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tell the broker to accept queued orders and execute the pending orders with
    the new data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the strategies’ `next` method to let the strategy evaluate the new data
    (and maybe issue orders which are queued in the broker)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Depending on the stage it may be `prenext` or `nextstart` before the minimum
    period requirements of the strategy/indicators are met
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Internally the strategies will also kick the `observers`, `indicators`, `analyzers`
    and other active elements
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tell any `writers` to write the data to its target
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Important to take into account:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In step `1` above when the *data feeds* deliver the new set of bars, those bars
    are **closed**. This means the data has already happened.
  prefs: []
  type: TYPE_NORMAL
- en: As such, *orders* issued by the strategy in step `4` cannot be *executed* with
    the data from step `1`.
  prefs: []
  type: TYPE_NORMAL
- en: This means that orders will be executed with the concept of `x + 1`. Where `x`
    is the bar moment at which the order was executed and `x + 1` the next one, which
    is the earliest moment in time for a possible order execution
  prefs: []
  type: TYPE_NORMAL
- en: Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: class backtrader.Cerebro()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Params:'
  prefs: []
  type: TYPE_NORMAL
- en: '`preload` (default: `True`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether to preload the different `data feeds` passed to cerebro for the Strategies
  prefs: []
  type: TYPE_NORMAL
- en: '`runonce` (default: `True`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run `Indicators` in vectorized mode to speed up the entire system. Strategies
    and Observers will always be run on an event based basis
  prefs: []
  type: TYPE_NORMAL
- en: '`live` (default: `False`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no data has reported itself as *live* (via the data’s `islive` method but
    the end user still want to run in `live` mode, this parameter can be set to true
  prefs: []
  type: TYPE_NORMAL
- en: This will simultaneously deactivate `preload` and `runonce`. It will have no
    effect on memory saving schemes.
  prefs: []
  type: TYPE_NORMAL
- en: Run `Indicators` in vectorized mode to speed up the entire system. Strategies
    and Observers will always be run on an event based basis
  prefs: []
  type: TYPE_NORMAL
- en: '`maxcpus` (default: None -> all available cores)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many cores to use simultaneously for optimization
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`stdstats` (default: `True`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If True default Observers will be added: Broker (Cash and Value), Trades and
    BuySell'
  prefs: []
  type: TYPE_NORMAL
- en: '`oldbuysell` (default: `False`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `stdstats` is `True` and observers are getting automatically added, this
    switch controls the main behavior of the `BuySell` observer
  prefs: []
  type: TYPE_NORMAL
- en: '`False`: use the modern behavior in which the buy / sell signals are plotted
    below / above the low / high prices respectively to avoid cluttering the plot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`True`: use the deprecated behavior in which the buy / sell signals are plotted
    where the average price of the order executions for the given moment in time is.
    This will of course be on top of an OHLC bar or on a Line on Cloe bar, difficulting
    the recognition of the plot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oldtrades` (default: `False`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `stdstats` is `True` and observers are getting automatically added, this
    switch controls the main behavior of the `Trades` observer
  prefs: []
  type: TYPE_NORMAL
- en: '`False`: use the modern behavior in which trades for all datas are plotted
    with different markers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`True`: use the old Trades observer which plots the trades with the same markers,
    differentiating only if they are positive or negative'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exactbars` (default: `False`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the default value each and every value stored in a line is kept in memory
  prefs: []
  type: TYPE_NORMAL
- en: 'Possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`objcache` (default: `False`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Experimental option to implement a cache of lines objects and reduce the amount
    of them. Example from UltimateOscillator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If this is `True` the 2^(nd) `TrueLow(self.data)` inside `TrueRange` matches
    the signature of the one in the `bp` calculation. It will be reused.
  prefs: []
  type: TYPE_NORMAL
- en: Corner cases may happen in which this drives a line object off its minimum period
    and breaks things and it is therefore disabled.
  prefs: []
  type: TYPE_NORMAL
- en: '`writer` (default: `False`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If set to `True` a default WriterFile will be created which will print to stdout.
    It will be added to the strategy (in addition to any other writers added by the
    user code)
  prefs: []
  type: TYPE_NORMAL
- en: '`tradehistory` (default: `False`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If set to `True`, it will activate update event logging in each trade for all
    strategies. This can also be accomplished on a per strategy basis with the strategy
    method `set_tradehistory`
  prefs: []
  type: TYPE_NORMAL
- en: '`optdatas` (default: `True`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `True` and optimizing (and the system can `preload` and use `runonce`, data
    preloading will be done only once in the main process to save time and resources.
  prefs: []
  type: TYPE_NORMAL
- en: The tests show an approximate `20%` speed-up moving from a sample execution
    in `83` seconds to `66`
  prefs: []
  type: TYPE_NORMAL
- en: '`optreturn` (default: `True`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If `True` the optimization results will not be full `Strategy` objects (and
    all *datas*, *indicators*, *observers* …) but and object with the following attributes
    (same as in `Strategy`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In most occassions, only the *analyzers* and with which *params* are the things
    needed to evaluate a the performance of a strategy. If detailed analysis of the
    generated values for (for example) *indicators* is needed, turn this off
  prefs: []
  type: TYPE_NORMAL
- en: The tests show a `13% - 15%` improvement in execution time. Combined with `optdatas`
    the total gain increases to a total speed-up of `32%` in an optimization run.
  prefs: []
  type: TYPE_NORMAL
- en: '`oldsync` (default: `False`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting with release 1.9.0.99 the synchronization of multiple datas (same or
    different timeframes) has been changed to allow datas of different lengths.
  prefs: []
  type: TYPE_NORMAL
- en: If the old behavior with data0 as the master of the system is wished, set this
    parameter to true
  prefs: []
  type: TYPE_NORMAL
- en: '`tz` (default: `None`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds a global timezone for strategies. The argument `tz` can be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`cheat_on_open` (default: `False`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `next_open` method of strategies will be called. This happens before `next`
    and before the broker has had a chance to evaluate orders. The indicators have
    not yet been recalculated. This allows issuing an orde which takes into account
    the indicators of the previous day but uses the `open` price for stake calculations
  prefs: []
  type: TYPE_NORMAL
- en: For cheat_on_open order execution, it is also necessary to make the call `cerebro.broker.set_coo(True)`
    or instantite a broker with `BackBroker(coo=True)` (where *coo* stands for cheat-on-open)
    or set the `broker_coo` parameter to `True`. Cerebro will do it automatically
    unless disabled below.
  prefs: []
  type: TYPE_NORMAL
- en: '`broker_coo` (default: `True`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will automatically invoke the `set_coo` method of the broker with `True`
    to activate `cheat_on_open` execution. Will only do it if `cheat_on_open` is also
    `True`
  prefs: []
  type: TYPE_NORMAL
- en: '`quicknotify` (default: `False`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Broker notifications are delivered right before the delivery of the *next* prices.
    For backtesting this has no implications, but with live brokers a notification
    can take place long before the bar is delivered. When set to `True` notifications
    will be delivered as soon as possible (see `qcheck` in live feeds)
  prefs: []
  type: TYPE_NORMAL
- en: Set to `False` for compatibility. May be changed to `True`
  prefs: []
  type: TYPE_NORMAL
- en: addstorecb(callback)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adds a callback to get messages which would be handled by the notify_store method
  prefs: []
  type: TYPE_NORMAL
- en: 'The signature of the callback must support the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`callback(msg, *args, **kwargs)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual `msg`, `*args` and `**kwargs` received are implementation defined
    (depend entirely on the *data/broker/store*) but in general one should expect
    them to be *printable* to allow for reception and experimentation.
  prefs: []
  type: TYPE_NORMAL
- en: notify_store(msg, *args, **kwargs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Receive store notifications in cerebro
  prefs: []
  type: TYPE_NORMAL
- en: This method can be overridden in `Cerebro` subclasses
  prefs: []
  type: TYPE_NORMAL
- en: The actual `msg`, `*args` and `**kwargs` received are implementation defined
    (depend entirely on the *data/broker/store*) but in general one should expect
    them to be *printable* to allow for reception and experimentation.
  prefs: []
  type: TYPE_NORMAL
- en: adddatacb(callback)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adds a callback to get messages which would be handled by the notify_data method
  prefs: []
  type: TYPE_NORMAL
- en: 'The signature of the callback must support the following:'
  prefs: []
  type: TYPE_NORMAL
- en: callback(data, status, *args, **kwargs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual `*args` and `**kwargs` received are implementation defined (depend
    entirely on the *data/broker/store*) but in general one should expect them to
    be *printable* to allow for reception and experimentation.
  prefs: []
  type: TYPE_NORMAL
- en: notify_data(data, status, *args, **kwargs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Receive data notifications in cerebro
  prefs: []
  type: TYPE_NORMAL
- en: This method can be overridden in `Cerebro` subclasses
  prefs: []
  type: TYPE_NORMAL
- en: The actual `*args` and `**kwargs` received are implementation defined (depend
    entirely on the *data/broker/store*) but in general one should expect them to
    be *printable* to allow for reception and experimentation.
  prefs: []
  type: TYPE_NORMAL
- en: adddata(data, name=None)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adds a `Data Feed` instance to the mix.
  prefs: []
  type: TYPE_NORMAL
- en: If `name` is not None it will be put into `data._name` which is meant for decoration/plotting
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: resampledata(dataname, name=None, **kwargs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adds a `Data Feed` to be resample by the system
  prefs: []
  type: TYPE_NORMAL
- en: If `name` is not None it will be put into `data._name` which is meant for decoration/plotting
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Any other kwargs like `timeframe`, `compression`, `todate` which are supported
    by the resample filter will be passed transparently
  prefs: []
  type: TYPE_NORMAL
- en: replaydata(dataname, name=None, **kwargs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adds a `Data Feed` to be replayed by the system
  prefs: []
  type: TYPE_NORMAL
- en: If `name` is not None it will be put into `data._name` which is meant for decoration/plotting
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Any other kwargs like `timeframe`, `compression`, `todate` which are supported
    by the replay filter will be passed transparently
  prefs: []
  type: TYPE_NORMAL
- en: chaindata(*args, **kwargs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Chains several data feeds into one
  prefs: []
  type: TYPE_NORMAL
- en: If `name` is passed as named argument and is not None it will be put into `data._name`
    which is meant for decoration/plotting purposes.
  prefs: []
  type: TYPE_NORMAL
- en: If `None`, then the name of the 1^(st) data will be used
  prefs: []
  type: TYPE_NORMAL
- en: rolloverdata(*args, **kwargs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Chains several data feeds into one
  prefs: []
  type: TYPE_NORMAL
- en: If `name` is passed as named argument and is not None it will be put into `data._name`
    which is meant for decoration/plotting purposes.
  prefs: []
  type: TYPE_NORMAL
- en: If `None`, then the name of the 1^(st) data will be used
  prefs: []
  type: TYPE_NORMAL
- en: Any other kwargs will be passed to the RollOver class
  prefs: []
  type: TYPE_NORMAL
- en: addstrategy(strategy, *args, **kwargs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adds a `Strategy` class to the mix for a single pass run. Instantiation will
    happen during `run` time.
  prefs: []
  type: TYPE_NORMAL
- en: args and kwargs will be passed to the strategy as they are during instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: Returns the index with which addition of other objects (like sizers) can be
    referenced
  prefs: []
  type: TYPE_NORMAL
- en: optstrategy(strategy, *args, **kwargs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adds a `Strategy` class to the mix for optimization. Instantiation will happen
    during `run` time.
  prefs: []
  type: TYPE_NORMAL
- en: args and kwargs MUST BE iterables which hold the values to check.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: if a Strategy accepts a parameter `period`, for optimization purposes
    the call to `optstrategy` looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: cerebro.optstrategy(MyStrategy, period=(15, 25))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will execute an optimization for values 15 and 25\. Whereas
  prefs: []
  type: TYPE_NORMAL
- en: cerebro.optstrategy(MyStrategy, period=range(15, 25))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: will execute MyStrategy with `period` values 15 -> 25 (25 not included, because
    ranges are semi-open in Python)
  prefs: []
  type: TYPE_NORMAL
- en: 'If a parameter is passed but shall not be optimized the call looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: cerebro.optstrategy(MyStrategy, period=(15,))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that `period` is still passed as an iterable … of just 1 element
  prefs: []
  type: TYPE_NORMAL
- en: '`backtrader` will anyhow try to identify situations like:'
  prefs: []
  type: TYPE_NORMAL
- en: cerebro.optstrategy(MyStrategy, period=15)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and will create an internal pseudo-iterable if possible
  prefs: []
  type: TYPE_NORMAL
- en: optcallback(cb)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adds a *callback* to the list of callbacks that will be called with the optimizations
    when each of the strategies has been run
  prefs: []
  type: TYPE_NORMAL
- en: 'The signature: cb(strategy)'
  prefs: []
  type: TYPE_NORMAL
- en: addindicator(indcls, *args, **kwargs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adds an `Indicator` class to the mix. Instantiation will be done at `run` time
    in the passed strategies
  prefs: []
  type: TYPE_NORMAL
- en: addobserver(obscls, *args, **kwargs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adds an `Observer` class to the mix. Instantiation will be done at `run` time
  prefs: []
  type: TYPE_NORMAL
- en: addobservermulti(obscls, *args, **kwargs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adds an `Observer` class to the mix. Instantiation will be done at `run` time
  prefs: []
  type: TYPE_NORMAL
- en: It will be added once per “data” in the system. A use case is a buy/sell observer
    which observes individual datas.
  prefs: []
  type: TYPE_NORMAL
- en: A counter-example is the CashValue, which observes system-wide values
  prefs: []
  type: TYPE_NORMAL
- en: addanalyzer(ancls, *args, **kwargs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adds an `Analyzer` class to the mix. Instantiation will be done at `run` time
  prefs: []
  type: TYPE_NORMAL
- en: addwriter(wrtcls, *args, **kwargs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adds an `Writer` class to the mix. Instantiation will be done at `run` time
    in cerebro
  prefs: []
  type: TYPE_NORMAL
- en: run(**kwargs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The core method to perform backtesting. Any `kwargs` passed to it will affect
    the value of the standard parameters `Cerebro` was instantiated with.
  prefs: []
  type: TYPE_NORMAL
- en: If `cerebro` has not datas the method will immediately bail out.
  prefs: []
  type: TYPE_NORMAL
- en: 'It has different return values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For No Optimization: a list contanining instances of the Strategy classes added
    with `addstrategy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Optimization: a list of lists which contain instances of the Strategy classes
    added with `addstrategy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: runstop()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If invoked from inside a strategy or anywhere else, including other threads
    the execution will stop as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: setbroker(broker)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sets a specific `broker` instance for this strategy, replacing the one inherited
    from cerebro.
  prefs: []
  type: TYPE_NORMAL
- en: getbroker()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Returns the broker instance.
  prefs: []
  type: TYPE_NORMAL
- en: This is also available as a `property` by the name `broker`
  prefs: []
  type: TYPE_NORMAL
- en: plot(plotter=None, numfigs=1, iplot=True, start=None, end=None, width=16, height=9,
    dpi=300, tight=True, use=None, **kwargs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Plots the strategies inside cerebro
  prefs: []
  type: TYPE_NORMAL
- en: If `plotter` is None a default `Plot` instance is created and `kwargs` are passed
    to it during instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: '`numfigs` split the plot in the indicated number of charts reducing chart density
    if wished'
  prefs: []
  type: TYPE_NORMAL
- en: '`iplot`: if `True` and running in a `notebook` the charts will be displayed
    inline'
  prefs: []
  type: TYPE_NORMAL
- en: '`use`: set it to the name of the desired matplotlib backend. It will take precedence
    over `iplot`'
  prefs: []
  type: TYPE_NORMAL
- en: '`start`: An index to the datetime line array of the strategy or a `datetime.date`,
    `datetime.datetime` instance indicating the start of the plot'
  prefs: []
  type: TYPE_NORMAL
- en: '`end`: An index to the datetime line array of the strategy or a `datetime.date`,
    `datetime.datetime` instance indicating the end of the plot'
  prefs: []
  type: TYPE_NORMAL
- en: '`width`: in inches of the saved figure'
  prefs: []
  type: TYPE_NORMAL
- en: '`height`: in inches of the saved figure'
  prefs: []
  type: TYPE_NORMAL
- en: '`dpi`: quality in dots per inches of the saved figure'
  prefs: []
  type: TYPE_NORMAL
- en: '`tight`: only save actual content and not the frame of the figure'
  prefs: []
  type: TYPE_NORMAL
- en: addsizer(sizercls, *args, **kwargs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adds a `Sizer` class (and args) which is the default sizer for any strategy
    added to cerebro
  prefs: []
  type: TYPE_NORMAL
- en: addsizer_byidx(idx, sizercls, *args, **kwargs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adds a `Sizer` class by idx. This idx is a reference compatible to the one returned
    by `addstrategy`. Only the strategy referenced by `idx` will receive this size
  prefs: []
  type: TYPE_NORMAL
- en: add_signal(sigtype, sigcls, *sigargs, **sigkwargs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adds a signal to the system which will be later added to a `SignalStrategy`
  prefs: []
  type: TYPE_NORMAL
- en: signal_concurrent(onoff)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If signals are added to the system and the `concurrent` value is set to True,
    concurrent orders will be allowed
  prefs: []
  type: TYPE_NORMAL
- en: signal_accumulate(onoff)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If signals are added to the system and the `accumulate` value is set to True,
    entering the market when already in the market, will be allowed to increase a
    position
  prefs: []
  type: TYPE_NORMAL
- en: signal_strategy(stratcls, *args, **kwargs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adds a SignalStrategy subclass which can accept signals
  prefs: []
  type: TYPE_NORMAL
- en: addcalendar(cal)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adds a global trading calendar to the system. Individual data feeds may have
    separate calendars which override the global one
  prefs: []
  type: TYPE_NORMAL
- en: '`cal` can be an instance of `TradingCalendar` a string or an instance of `pandas_market_calendars`.
    A string will be will be instantiated as a `PandasMarketCalendar` (which needs
    the module `pandas_market_calendar` installed in the system.'
  prefs: []
  type: TYPE_NORMAL
- en: If a subclass of TradingCalendarBase is passed (not an instance) it will be
    instantiated
  prefs: []
  type: TYPE_NORMAL
- en: addtz(tz)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This can also be done with the parameter `tz`
  prefs: []
  type: TYPE_NORMAL
- en: Adds a global timezone for strategies. The argument `tz` can be
  prefs: []
  type: TYPE_NORMAL
- en: '`None`: in this case the datetime displayed by strategies will be in UTC, which
    has been always the standard behavior'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytz` instance. It will be used as such to convert UTC times to the chosen
    timezone'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`. Instantiating a `pytz` instance will be attempted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`integer`. Use, for the strategy, the same timezone as the corresponding `data`
    in the `self.datas` iterable (`0` would use the timezone from `data0`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: add_timer(when, offset=datetime.timedelta(0), repeat=datetime.timedelta(0),
    weekdays=[], weekcarry=False, monthdays=[], monthcarry=True, allow=None, tzdata=None,
    strats=False, cheat=False, *args, **kwargs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Schedules a timer to invoke `notify_timer`
  prefs: []
  type: TYPE_NORMAL
- en: '**Parameters**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**when** (*-*) – can be'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`datetime.time` instance (see below `tzdata`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bt.timer.SESSION_START` to reference a session start'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bt.timer.SESSION_END` to reference a session end'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`offset` which must be a `datetime.timedelta` instance'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Used to offset the value `when`. It has a meaningful use in combination with
    `SESSION_START` and `SESSION_END`, to indicated things like a timer being called
    `15 minutes` after the session start.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`repeat` which must be a `datetime.timedelta` instance'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Indicates if after a 1^(st) call, further calls will be scheduled within the
    same session at the scheduled `repeat` delta
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the timer goes over the end of the session it is reset to the original
    value for `when`
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`weekdays`: a **sorted** iterable with integers indicating on which days (iso
    codes, Monday is 1, Sunday is 7) the timers can be actually invoked'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If not specified, the timer will be active on all days
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`weekcarry` (default: `False`). If `True` and the weekday was not seen (ex:
    trading holiday), the timer will be executed on the next day (even if in a new
    week)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`monthdays`: a **sorted** iterable with integers indicating on which days of
    the month a timer has to be executed. For example always on day *15* of the month'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If not specified, the timer will be active on all days
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`monthcarry` (default: `True`). If the day was not seen (weekend, trading holiday),
    the timer will be executed on the next available day.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allow` (default: `None`). A callback which receives a datetime.date` instance
    and returns `True` if the date is allowed for timers or else returns `False`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tzdata` which can be either `None` (default), a `pytz` instance or a `data
    feed` instance.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`None`: `when` is interpreted at face value (which translates to handling it
    as if it where UTC even if it’s not)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`pytz` instance: `when` will be interpreted as being specified in the local
    time specified by the timezone instance.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`data feed` instance: `when` will be interpreted as being specified in the
    local time specified by the `tz` parameter of the data feed instance.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: If `when` is either `SESSION_START` or `SESSION_END` and `tzdata` is `None`,
    the 1^(st) *data feed* in the system (aka `self.data0`) will be used as the reference
    to find out the session times.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`strats` (default: `False`) call also the `notify_timer` of strategies'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cheat` (default `False`) if `True` the timer will be called before the broker
    has a chance to evaluate the orders. This opens the chance to issue orders based
    on opening price for example right before the session starts'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*args`: any extra args will be passed to `notify_timer`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kwargs`: any extra kwargs will be passed to `notify_timer`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Return Value:'
  prefs: []
  type: TYPE_NORMAL
- en: The created timer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: notify_timer(timer, when, *args, **kwargs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Receives a timer notification where `timer` is the timer which was returned
    by `add_timer`, and `when` is the calling time. `args` and `kwargs` are any additional
    arguments passed to `add_timer`
  prefs: []
  type: TYPE_NORMAL
- en: The actual `when` time can be later, but the system may have not be able to
    call the timer before. This value is the timer value and no the system time.
  prefs: []
  type: TYPE_NORMAL
- en: add_order_history(orders, notify=True)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Add a history of orders to be directly executed in the broker for performance
    evaluation
  prefs: []
  type: TYPE_NORMAL
- en: '`orders`: is an iterable (ex: list, tuple, iterator, generator) in which each
    element will be also an iterable (with length) with the following sub-elements
    (2 formats are possible)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[datetime, size, price]` or `[datetime, size, price, data]`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it must be sorted (or produce sorted elements) by datetime ascending
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'where:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`datetime` is a python `date/datetime` instance or a string with format YYYY-MM-DD[THH:MM:SS[.us]]
    where the elements in brackets are optional'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size` is an integer (positive to *buy*, negative to *sell*)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`price` is a float/integer'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data` if present can take any of the following values'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*None* - The 1^(st) data feed will be used as target'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*integer* - The data with that index (insertion order in **Cerebro**) will
    be used'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*string* - a data with that name, assigned for example with `cerebro.addata(data,
    name=value)`, will be the target'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notify` (default: *True*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `True` the 1^(st) strategy inserted in the system will be notified of the
    artificial orders created following the information from each order in `orders`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Implicit in the description is the need to add a data feed which is the target
    of the orders. This is for example needed by analyzers which track for example
    the returns
  prefs: []
  type: TYPE_NORMAL
