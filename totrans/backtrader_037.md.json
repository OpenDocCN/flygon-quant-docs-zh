["```py\n    `(Seconds, 1) -> (Days, 1)` \n    ```", "```py\n`data = MyDataFeed(dataname=myname)\ndata.addfilter(filter, *args, **kwargs)\ncerebro.addata(data)` \n```", "```py\n`data = MyDataFeed(dataname=myname)\ndata.addfilter(filter, *args, **kwargs)\ncerebro.replaydata(data)` \n```", "```py\n    `callable(data, *args, **kwargs)` \n    ```", "```py\n    `def __init__(self, data, *args, **kwargs)` \n    ```", "```py\n    `def __call__(self, data, *args, **kwargs)` \n    ```", "```py\n    `* `True`: the inner data fetching loop of the data feed must retry\n      fetching data from the feed, becaue the length of the stream was\n      manipulated\n\n    * `False` even if data may have been edited (example: changed\n      `close` price), the length of the stream has remain untouched` \n    ```", "```py\n    `def last(self, data, *args, **kwargs)` \n    ```", "```py\n`def __init__(self, data, *args, **kwargs) -> def __init__(self, data)` \n```", "```py\n`class SessionFilter(object):\n    def __init__(self, data):\n        pass\n\n    def __call__(self, data):\n        if data.p.sessionstart <= data.datetime.time() <= data.p.sessionend:\n            # bar is in the session\n            return False  # tell outer data loop the bar can be processed\n\n        # bar outside of the regular session times\n        data.backwards()  # remove bar from data stack\n        return True  # tell outer data loop to fetch a new bar` \n```", "```py\n    `With Len X     -> OHL\n    With Len X     -> OHLC\n    With Len X + 1 -> OHL\n    With Len X + 1 -> OHLC\n    With Len X + 2 -> OHL\n    With Len X + 2 -> OHLC\n    ...` \n    ```", "```py\n`class DaySplitter_Close(bt.with_metaclass(bt.MetaParams, object)):\n  '''\n Splits a daily bar in two parts simulating 2 ticks which will be used to\n replay the data:\n\n - First tick: ``OHLX``\n\n The ``Close`` will be replaced by the *average* of ``Open``, ``High``\n and ``Low``\n\n The session opening time is used for this tick\n\n and\n\n - Second tick: ``CCCC``\n\n The ``Close`` price will be used for the four components of the price\n\n The session closing time is used for this tick\n\n The volume will be split amongst the 2 ticks using the parameters:\n\n - ``closevol`` (default: ``0.5``) The value indicate which percentage, in\n absolute terms from 0.0 to 1.0, has to be assigned to the *closing*\n tick. The rest will be assigned to the ``OHLX`` tick.\n\n **This filter is meant to be used together with** ``cerebro.replaydata``\n\n '''\n    params = (\n        ('closevol', 0.5),  # 0 -> 1 amount of volume to keep for close\n    )\n\n    # replaying = True\n\n    def __init__(self, data):\n        self.lastdt = None\n\n    def __call__(self, data):\n        # Make a copy of the new bar and remove it from stream\n        datadt = data.datetime.date()  # keep the date\n\n        if self.lastdt == datadt:\n            return False  # skip bars that come again in the filter\n\n        self.lastdt = datadt  # keep ref to last seen bar\n\n        # Make a copy of current data for ohlbar\n        ohlbar = [data.lines[i][0] for i in range(data.size())]\n        closebar = ohlbar[:]  # Make a copy for the close\n\n        # replace close price with o-h-l average\n        ohlprice = ohlbar[data.Open] + ohlbar[data.High] + ohlbar[data.Low]\n        ohlbar[data.Close] = ohlprice / 3.0\n\n        vol = ohlbar[data.Volume]  # adjust volume\n        ohlbar[data.Volume] = vohl = int(vol * (1.0 - self.p.closevol))\n\n        oi = ohlbar[data.OpenInterest]  # adjust open interst\n        ohlbar[data.OpenInterest] = 0\n\n        # Adjust times\n        dt = datetime.datetime.combine(datadt, data.p.sessionstart)\n        ohlbar[data.DateTime] = data.date2num(dt)\n\n        # Ajust closebar to generate a single tick -> close price\n        closebar[data.Open] = cprice = closebar[data.Close]\n        closebar[data.High] = cprice\n        closebar[data.Low] = cprice\n        closebar[data.Volume] = vol - vohl\n        ohlbar[data.OpenInterest] = oi\n\n        # Adjust times\n        dt = datetime.datetime.combine(datadt, data.p.sessionend)\n        closebar[data.DateTime] = data.date2num(dt)\n\n        # Update stream\n        data.backwards(force=True)  # remove the copied bar from stream\n        data._add2stack(ohlbar)  # add ohlbar to stack\n        # Add 2nd part to stash to delay processing to next round\n        data._add2stack(closebar, stash=True)\n\n        return False  # initial tick can be further processed from stack` \n```"]