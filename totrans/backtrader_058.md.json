["```py\n`brackets = self.buy_bracket(limitprice=14.00, price=13.50, stopprice=13.00)` \n```", "```py\n`mainside = self.buy(price=13.50, exectype=bt.Order.Limit, transmit=False)\nlowside  = self.sell(price=13.00, size=mainside.size, exectype=bt.Order.Stop,\n                     transmit=False, parent=mainside)\nhighside = self.sell(price=14.00, size=mainside.size, exectype=bt.Order.Limit,\n                     transmit=True, parent=mainside)` \n```", "```py\n`$ ./bracket.py --plot\n\n2005-01-28: Oref 1 / Buy at 2941.11055\n2005-01-28: Oref 2 / Sell Stop at 2881.99275\n2005-01-28: Oref 3 / Sell Limit at 3000.22835\n2005-01-31: Order ref: 1 / Type Buy / Status Submitted\n2005-01-31: Order ref: 2 / Type Sell / Status Submitted\n2005-01-31: Order ref: 3 / Type Sell / Status Submitted\n2005-01-31: Order ref: 1 / Type Buy / Status Accepted\n2005-01-31: Order ref: 2 / Type Sell / Status Accepted\n2005-01-31: Order ref: 3 / Type Sell / Status Accepted\n2005-02-01: Order ref: 1 / Type Buy / Status Expired\n2005-02-01: Order ref: 2 / Type Sell / Status Canceled\n2005-02-01: Order ref: 3 / Type Sell / Status Canceled\n...\n2005-08-11: Oref 16 / Buy at 3337.3892\n2005-08-11: Oref 17 / Sell Stop at 3270.306\n2005-08-11: Oref 18 / Sell Limit at 3404.4724\n2005-08-12: Order ref: 16 / Type Buy / Status Submitted\n2005-08-12: Order ref: 17 / Type Sell / Status Submitted\n2005-08-12: Order ref: 18 / Type Sell / Status Submitted\n2005-08-12: Order ref: 16 / Type Buy / Status Accepted\n2005-08-12: Order ref: 17 / Type Sell / Status Accepted\n2005-08-12: Order ref: 18 / Type Sell / Status Accepted\n2005-08-12: Order ref: 16 / Type Buy / Status Completed\n2005-08-18: Order ref: 17 / Type Sell / Status Completed\n2005-08-18: Order ref: 18 / Type Sell / Status Canceled\n...\n2005-09-26: Oref 22 / Buy at 3383.92535\n2005-09-26: Oref 23 / Sell Stop at 3315.90675\n2005-09-26: Oref 24 / Sell Limit at 3451.94395\n2005-09-27: Order ref: 22 / Type Buy / Status Submitted\n2005-09-27: Order ref: 23 / Type Sell / Status Submitted\n2005-09-27: Order ref: 24 / Type Sell / Status Submitted\n2005-09-27: Order ref: 22 / Type Buy / Status Accepted\n2005-09-27: Order ref: 23 / Type Sell / Status Accepted\n2005-09-27: Order ref: 24 / Type Sell / Status Accepted\n2005-09-27: Order ref: 22 / Type Buy / Status Completed\n2005-10-04: Order ref: 24 / Type Sell / Status Completed\n2005-10-04: Order ref: 23 / Type Sell / Status Canceled\n...` \n```", "```py\n`$ ./bracket.py --strat usebracket=True` \n```", "```py\n`def buy_bracket(self, data=None, size=None, price=None, plimit=None,\n                exectype=bt.Order.Limit, valid=None, tradeid=0,\n                trailamount=None, trailpercent=None, oargs={},\n                stopprice=None, stopexec=bt.Order.Stop, stopargs={},\n                limitprice=None, limitexec=bt.Order.Limit, limitargs={},\n                **kwargs):\n  '''\n Create a bracket order group (low side - buy order - high side). The\n default behavior is as follows:\n\n - Issue a **buy** order with execution ``Limit`\n\n - Issue a *low side* bracket **sell** order with execution ``Stop``\n\n - Issue a *high side* bracket **sell** order with execution\n ``Limit``.\n\n See below for the different parameters\n\n - ``data`` (default: ``None``)\n\n For which data the order has to be created. If ``None`` then the\n first data in the system, ``self.datas[0] or self.data0`` (aka\n ``self.data``) will be used\n\n - ``size`` (default: ``None``)\n\n Size to use (positive) of units of data to use for the order.\n\n If ``None`` the ``sizer`` instance retrieved via ``getsizer`` will\n be used to determine the size.\n\n **Note**: The same size is applied to all 3 orders of the bracket\n\n - ``price`` (default: ``None``)\n\n Price to use (live brokers may place restrictions on the actual\n format if it does not comply to minimum tick size requirements)\n\n ``None`` is valid for ``Market`` and ``Close`` orders (the market\n determines the price)\n\n For ``Limit``, ``Stop`` and ``StopLimit`` orders this value\n determines the trigger point (in the case of ``Limit`` the trigger\n is obviously at which price the order should be matched)\n\n - ``plimit`` (default: ``None``)\n\n Only applicable to ``StopLimit`` orders. This is the price at which\n to set the implicit *Limit* order, once the *Stop* has been\n triggered (for which ``price`` has been used)\n\n - ``trailamount`` (default: ``None``)\n\n If the order type is StopTrail or StopTrailLimit, this is an\n absolute amount which determines the distance to the price (below\n for a Sell order and above for a buy order) to keep the trailing\n stop\n\n - ``trailpercent`` (default: ``None``)\n\n If the order type is StopTrail or StopTrailLimit, this is a\n percentage amount which determines the distance to the price (below\n for a Sell order and above for a buy order) to keep the trailing\n stop (if ``trailamount`` is also specified it will be used)\n\n - ``exectype`` (default: ``bt.Order.Limit``)\n\n Possible values: (see the documentation for the method ``buy``\n\n - ``valid`` (default: ``None``)\n\n Possible values: (see the documentation for the method ``buy``\n\n - ``tradeid`` (default: ``0``)\n\n Possible values: (see the documentation for the method ``buy``\n\n - ``oargs`` (default: ``{}``)\n\n Specific keyword arguments (in a ``dict``) to pass to the main side\n order. Arguments from the default ``**kwargs`` will be applied on\n top of this.\n\n - ``**kwargs``: additional broker implementations may support extra\n parameters. ``backtrader`` will pass the *kwargs* down to the\n created order objects\n\n Possible values: (see the documentation for the method ``buy``\n\n **Note**: this ``kwargs`` will be applied to the 3 orders of a\n bracket. See below for specific keyword arguments for the low and\n high side orders\n\n - ``stopprice`` (default: ``None``)\n\n Specific price for the *low side* stop order\n\n - ``stopexec`` (default: ``bt.Order.Stop``)\n\n Specific execution type for the *low side* order\n\n - ``stopargs`` (default: ``{}``)\n\n Specific keyword arguments (in a ``dict``) to pass to the low side\n order. Arguments from the default ``**kwargs`` will be applied on\n top of this.\n\n - ``limitprice`` (default: ``None``)\n\n Specific price for the *high side* stop order\n\n - ``stopexec`` (default: ``bt.Order.Limit``)\n\n Specific execution type for the *high side* order\n\n - ``limitargs`` (default: ``{}``)\n\n Specific keyword arguments (in a ``dict``) to pass to the high side\n order. Arguments from the default ``**kwargs`` will be applied on\n top of this.\n\n Returns:\n - A list containing the 3 bracket orders [order, stop side, limit\n side]\n '''\n\ndef sell_bracket(self, data=None,\n                 size=None, price=None, plimit=None,\n                 exectype=bt.Order.Limit, valid=None, tradeid=0,\n                 trailamount=None, trailpercent=None,\n                 oargs={},\n                 stopprice=None, stopexec=bt.Order.Stop, stopargs={},\n                 limitprice=None, limitexec=bt.Order.Limit, limitargs={},\n                 **kwargs):\n  '''\n Create a bracket order group (low side - buy order - high side). The\n default behavior is as follows:\n\n - Issue a **sell** order with execution ``Limit`\n\n - Issue a *high side* bracket **buy** order with execution ``Stop``\n\n - Issue a *low side* bracket **buy** order with execution ``Limit``.\n\n See ``bracket_buy`` for the meaning of the parameters\n\n Returns:\n - A list containing the 3 bracket orders [order, stop side, limit\n side]\n '''` \n```", "```py\n`$ ./bracket.py --help\nusage: bracket.py [-h] [--data0 DATA0] [--fromdate FROMDATE] [--todate TODATE]\n                  [--cerebro kwargs] [--broker kwargs] [--sizer kwargs]\n                  [--strat kwargs] [--plot [kwargs]]\n\nSample Skeleton\n\noptional arguments:\n  -h, --help           show this help message and exit\n  --data0 DATA0        Data to read in (default:\n                       ../../datas/2005-2006-day-001.txt)\n  --fromdate FROMDATE  Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: )\n  --todate TODATE      Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: )\n  --cerebro kwargs     kwargs in key=value format (default: )\n  --broker kwargs      kwargs in key=value format (default: )\n  --sizer kwargs       kwargs in key=value format (default: )\n  --strat kwargs       kwargs in key=value format (default: )\n  --plot [kwargs]      kwargs in key=value format (default: )` \n```", "```py\n`from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport argparse\nimport datetime\n\nimport backtrader as bt\n\nclass St(bt.Strategy):\n    params = dict(\n        ma=bt.ind.SMA,\n        p1=5,\n        p2=15,\n        limit=0.005,\n        limdays=3,\n        limdays2=1000,\n        hold=10,\n        usebracket=False,  # use order_target_size\n        switchp1p2=False,  # switch prices of order1 and order2\n    )\n\n    def notify_order(self, order):\n        print('{}: Order ref: {} / Type {} / Status {}'.format(\n            self.data.datetime.date(0),\n            order.ref, 'Buy' * order.isbuy() or 'Sell',\n            order.getstatusname()))\n\n        if order.status == order.Completed:\n            self.holdstart = len(self)\n\n        if not order.alive() and order.ref in self.orefs:\n            self.orefs.remove(order.ref)\n\n    def __init__(self):\n        ma1, ma2 = self.p.ma(period=self.p.p1), self.p.ma(period=self.p.p2)\n        self.cross = bt.ind.CrossOver(ma1, ma2)\n\n        self.orefs = list()\n\n        if self.p.usebracket:\n            print('-' * 5, 'Using buy_bracket')\n\n    def next(self):\n        if self.orefs:\n            return  # pending orders do nothing\n\n        if not self.position:\n            if self.cross > 0.0:  # crossing up\n\n                close = self.data.close[0]\n                p1 = close * (1.0 - self.p.limit)\n                p2 = p1 - 0.02 * close\n                p3 = p1 + 0.02 * close\n\n                valid1 = datetime.timedelta(self.p.limdays)\n                valid2 = valid3 = datetime.timedelta(self.p.limdays2)\n\n                if self.p.switchp1p2:\n                    p1, p2 = p2, p1\n                    valid1, valid2 = valid2, valid1\n\n                if not self.p.usebracket:\n                    o1 = self.buy(exectype=bt.Order.Limit,\n                                  price=p1,\n                                  valid=valid1,\n                                  transmit=False)\n\n                    print('{}: Oref {} / Buy at {}'.format(\n                        self.datetime.date(), o1.ref, p1))\n\n                    o2 = self.sell(exectype=bt.Order.Stop,\n                                   price=p2,\n                                   valid=valid2,\n                                   parent=o1,\n                                   transmit=False)\n\n                    print('{}: Oref {} / Sell Stop at {}'.format(\n                        self.datetime.date(), o2.ref, p2))\n\n                    o3 = self.sell(exectype=bt.Order.Limit,\n                                   price=p3,\n                                   valid=valid3,\n                                   parent=o1,\n                                   transmit=True)\n\n                    print('{}: Oref {} / Sell Limit at {}'.format(\n                        self.datetime.date(), o3.ref, p3))\n\n                    self.orefs = [o1.ref, o2.ref, o3.ref]\n\n                else:\n                    os = self.buy_bracket(\n                        price=p1, valid=valid1,\n                        stopprice=p2, stopargs=dict(valid=valid2),\n                        limitprice=p3, limitargs=dict(valid=valid3),)\n\n                    self.orefs = [o.ref for o in os]\n\n        else:  # in the market\n            if (len(self) - self.holdstart) >= self.p.hold:\n                pass  # do nothing in this case\n\ndef runstrat(args=None):\n    args = parse_args(args)\n\n    cerebro = bt.Cerebro()\n\n    # Data feed kwargs\n    kwargs = dict()\n\n    # Parse from/to-date\n    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'\n    for a, d in ((getattr(args, x), x) for x in ['fromdate', 'todate']):\n        if a:\n            strpfmt = dtfmt + tmfmt * ('T' in a)\n            kwargs[d] = datetime.datetime.strptime(a, strpfmt)\n\n    # Data feed\n    data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs)\n    cerebro.adddata(data0)\n\n    # Broker\n    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' + args.broker + ')'))\n\n    # Sizer\n    cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' + args.sizer + ')'))\n\n    # Strategy\n    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))\n\n    # Execute\n    cerebro.run(**eval('dict(' + args.cerebro + ')'))\n\n    if args.plot:  # Plot if requested to\n        cerebro.plot(**eval('dict(' + args.plot + ')'))\n\ndef parse_args(pargs=None):\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n        description=(\n            'Sample Skeleton'\n        )\n    )\n\n    parser.add_argument('--data0', default='../../datas/2005-2006-day-001.txt',\n                        required=False, help='Data to read in')\n\n    # Defaults for dates\n    parser.add_argument('--fromdate', required=False, default='',\n                        help='Date[time] in YYYY-MM-DD[THH:MM:SS] format')\n\n    parser.add_argument('--todate', required=False, default='',\n                        help='Date[time] in YYYY-MM-DD[THH:MM:SS] format')\n\n    parser.add_argument('--cerebro', required=False, default='',\n                        metavar='kwargs', help='kwargs in key=value format')\n\n    parser.add_argument('--broker', required=False, default='',\n                        metavar='kwargs', help='kwargs in key=value format')\n\n    parser.add_argument('--sizer', required=False, default='',\n                        metavar='kwargs', help='kwargs in key=value format')\n\n    parser.add_argument('--strat', required=False, default='',\n                        metavar='kwargs', help='kwargs in key=value format')\n\n    parser.add_argument('--plot', required=False, default='',\n                        nargs='?', const='{}',\n                        metavar='kwargs', help='kwargs in key=value format')\n\n    return parser.parse_args(pargs)\n\nif __name__ == '__main__':\n    runstrat()` \n```"]