- en: Analyzers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.backtrader.com/docu/analyzers/analyzers/](https://www.backtrader.com/docu/analyzers/analyzers/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Be it backtesting or trading, being able to analyze the performance of the trading
    system is key to understanding if not only profit has been attained, but also
    if it has been achieved with too much risk or if it was really worth the effort
    when compared with a reference asset (or a risk-free asset)
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s where the family of `Analyzer` objects comes in: provide an analysis
    of what’s happened or even of what’s actually happening.'
  prefs: []
  type: TYPE_NORMAL
- en: Nature of analyzers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The interface is modeled after that of *Lines* objects, feature for example
    a `next` method but there is a major difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Analyzers` do not hold lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That means they are not expensive in terms of memory because even after having
    analyzed thousands of price bars they may still simply hold a single result in
    memory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Location in the ecosystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Analyzer` objects are (like *strategies*, *observers* and *datas*) added to
    the system through a `cerebro` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addanalyzer(ancls, *args, **kwargs)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But when it comes to operation during `cerebro.run` the following will happen
    for each *strategy* present in the system
  prefs: []
  type: TYPE_NORMAL
- en: '`ancls` will be instantiated with `*args` and `**kwargs` during a `cerebro.run`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ancls` instance will be attached to the strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That means:'
  prefs: []
  type: TYPE_NORMAL
- en: If the backtesting run contains for example *3 strategies* then *3 instances*
    of `ancls` will be created and each of them will be attached to a different strategy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bottomline: *an analyzer analyzes the performance of a single strategy* and
    *not the performance of an entires system*'
  prefs: []
  type: TYPE_NORMAL
- en: Additional Location
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some `Analyzer` objects may actually use other analyzers to complete its work.
    For example: `SharpeRatio` uses the output of `TimeReturn` for the calculations.'
  prefs: []
  type: TYPE_NORMAL
- en: These *sub-analyzers* or *slave-analyzers* will also be inserted into the same
    strategy as the one creating them. But they are completely invisible to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To carry out the intended work, `Analyzer` objects are provided with some default
    attributes which are automagically passed and set in the instance for ease of
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`self.strategy`: reference to the strategy subclass in which the analyzer object
    is operating. Anything accessible by the *strategy* can also be accessd by the
    *analyzer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.datas[x]`: the array of data feeds present in the strategy. Although
    this could be accesed over the *strategy* reference, the shortcut makes work more
    comfortable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.data`: shortcut to `self.datas[0]` for extra comfort.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.dataX`: shortcuts to the different `self.datas[x]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some other aliases are available although they are probably an overkill:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If the line has a name, the following is also available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For the first data, the last two shortcuts are available without the initial
    `X` numeric reference. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: And
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Returning the analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Analyzer* base class creates a `self.rets` (of type `collections.OrderedDict`)
    member attribute to return the analysis. This is done in the method `create_analysis`
    which can be overriden by subclasses if creating custom analyzers.
  prefs: []
  type: TYPE_NORMAL
- en: Modus operandi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although `Analyzer` objects are not *Lines* objects and therefore do not iterate
    over lines, they have been designed to follow the same operation pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiated before the system is put into motion (therefore calling `__init__`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Signaled the begin of operations with `start`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`prenext` / `nextstart` / `next` will be invoked following the calculated minimum
    period of the *strategy* the indicator is working in.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default behaviour of `prenext` and `nextstart` is to invoke next, because
    an analyzer may be analyzing from the very first moment the system is alive.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It may be customary to call `len(self)` in *Lines* objects to check the actual
    amount of bars. This also works in `Analyzers` by returning the value for `self.strategy`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Orders and trades will be notified just like they are to the strategy via `notify_order`
    and `notify_trade`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cash and value will also be notified like it is done with the strategy over
    the `notify_cashvalue` method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cash, value and fundvalue and fund shares will also be notified like it is done
    with the strategy over the `notify_fund` method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`stop` will be invoked to signal the end of operations'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the regular operations cycle has been completed, the *analyzers* featuring
    additional methods for extracting/outputting information
  prefs: []
  type: TYPE_NORMAL
- en: '`get_analysis`: which ideally (not enforced) returnes a `dict` -like object
    containing the analysis results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print` uses a standard `backtrader.WriterFile` (unless overriden) to write
    the analysis result from `get_analysis`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pprint` (*pretty print*) uses the Python `pprint` module to print the `get_analysis`
    resutls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And finally:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get_analysis` creates a member attribute `self.ret` (of type `collections.OrderedDict`)
    to which analyzers write the analysis results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subclasses of *Analyzer* can override this method to change this behavior
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Analyzer Patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Development of *Analyzer* objects in the `backtrader` platform have revealed
    2 different usage patterns for the generation of the analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: During execution by gathering information in the `notify_xxx` and `next` methods,
    and generating the current information of the analysis in `next`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `TradeAnalyzer`, for example, uses just the `notify_trade` method to generate
    the statistics.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Gather (or not) the information as above, but generate the analysis in a single
    pass during the `stop` method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `SQN` (*System Quality Number*) gathers trade information during `notify_trade`
    but generates the statistic during the `stop` method
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A quick example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As easy as it can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing it (having stored it in `analyzer-test.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There is no plotting, because the `SharpeRatio` is a single value at the end
    of the calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Forensic Analysis of an Analyzer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s repeat that `Analyzers` are not Lines objects, but to seamlessly integrate
    them into the `backtrader` ecosystem, the internal API conventions of several
    Lines object are followed (actually a **mixture** of them)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The code for the `SharpeRatio` has evolved to take for example into account
    annualization and the version here should only be a reference.
  prefs: []
  type: TYPE_NORMAL
- en: Please check the Analyzers Reference
  prefs: []
  type: TYPE_NORMAL
- en: There is additionally a `SharpeRatio_A` which provides the value directly in
    annualized form regardless of the sought timeframe
  prefs: []
  type: TYPE_NORMAL
- en: Code for `SharpeRatio` to serve as a basis (a simplified version)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The code can be broken down into:'
  prefs: []
  type: TYPE_NORMAL
- en: '`params` declaration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the declared ones are not used (meant as an example), *Analyzers* like
    most other objects in `backtrader` support parameters
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`__init__` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just like *Strategies* declare *Indicators* in `__init__`, the same do analyzers
    with support objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In this case: the `SharpeRatio` is calculated using **Annual Returns**. The
    calculation will be automatic and will be available to `SharpeRatio` for its own
    calculations.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The actual implementation of `SharpeRatio` uses the more generic and later developed
    `TimeReturn` analyzer
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`next` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SharpeRatio` doesn’t need it, but this method will be called after each invocation
    of the parent strategy `next`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`start` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Called right before the backtesting starts. Can be used for extra initialization
    tasks. Sharperatio doesn’t need it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`stop` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Called right after the backtesting ends. Like `SharpeRatio` does, it can be
    used to finish/make the calculation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`get_analysis` method (returns a dictionary)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access for external callers to the produced analysis
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Returns: a dictionary with the analysis.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: class backtrader.Analyzer()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Analyzer base class. All analyzers are subclass of this one
  prefs: []
  type: TYPE_NORMAL
- en: An Analyzer instance operates in the frame of a strategy and provides an analysis
    for that strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Automagically set member attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`self.strategy` (giving access to the *strategy* and anything accessible from
    it)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.datas[x]` giving access to the array of data feeds present in the the
    system, which could also be accessed via the strategy reference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.data`, giving access to `self.datas[0]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.dataX` -> `self.datas[X]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.dataX_Y` -> `self.datas[X].lines[Y]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.dataX_name` -> `self.datas[X].name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.data_name` -> `self.datas[0].name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.data_Y` -> `self.datas[0].lines[Y]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is not a *Lines* object, but the methods and operation follow the same
    design
  prefs: []
  type: TYPE_NORMAL
- en: '`__init__` during instantiation and initial setup'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start` / `stop` to signal the begin and end of operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prenext` / `nextstart` / `next` family of methods that follow the calls made
    to the same methods in the strategy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notify_trade` / `notify_order` / `notify_cashvalue` / `notify_fund` which
    receive the same notifications as the equivalent methods of the strategy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mode of operation is open and no pattern is preferred. As such the analysis
    can be generated with the `next` calls, at the end of operations during `stop`
    and even with a single method like `notify_trade`
  prefs: []
  type: TYPE_NORMAL
- en: The important thing is to override `get_analysis` to return a *dict-like* object
    containing the results of the analysis (the actual format is implementation dependent)
  prefs: []
  type: TYPE_NORMAL
- en: start()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Invoked to indicate the start of operations, giving the analyzer time to setup
    up needed things
  prefs: []
  type: TYPE_NORMAL
- en: stop()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Invoked to indicate the end of operations, giving the analyzer time to shut
    down needed things
  prefs: []
  type: TYPE_NORMAL
- en: prenext()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Invoked for each prenext invocation of the strategy, until the minimum period
    of the strategy has been reached
  prefs: []
  type: TYPE_NORMAL
- en: The default behavior for an analyzer is to invoke `next`
  prefs: []
  type: TYPE_NORMAL
- en: nextstart()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Invoked exactly once for the nextstart invocation of the strategy, when the
    minimum period has been first reached
  prefs: []
  type: TYPE_NORMAL
- en: next()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Invoked for each next invocation of the strategy, once the minum preiod of the
    strategy has been reached
  prefs: []
  type: TYPE_NORMAL
- en: notify_cashvalue(cash, value)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Receives the cash/value notification before each next cycle
  prefs: []
  type: TYPE_NORMAL
- en: notify_fund(cash, value, fundvalue, shares)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Receives the current cash, value, fundvalue and fund shares
  prefs: []
  type: TYPE_NORMAL
- en: notify_order(order)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Receives order notifications before each next cycle
  prefs: []
  type: TYPE_NORMAL
- en: notify_trade(trade)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Receives trade notifications before each next cycle
  prefs: []
  type: TYPE_NORMAL
- en: get_analysis()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Returns a *dict-like* object with the results of the analysis
  prefs: []
  type: TYPE_NORMAL
- en: The keys and format of analysis results in the dictionary is implementation
    dependent.
  prefs: []
  type: TYPE_NORMAL
- en: It is not even enforced that the result is a *dict-like object*, just the convention
  prefs: []
  type: TYPE_NORMAL
- en: The default implementation returns the default OrderedDict `rets` created by
    the default `create_analysis` method
  prefs: []
  type: TYPE_NORMAL
- en: create_analysis()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Meant to be overriden by subclasses. Gives a chance to create the structures
    that hold the analysis.
  prefs: []
  type: TYPE_NORMAL
- en: The default behaviour is to create a `OrderedDict` named `rets`
  prefs: []
  type: TYPE_NORMAL
- en: print(*args, **kwargs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Prints the results returned by `get_analysis` via a standard `Writerfile` object,
    which defaults to writing things to standard output
  prefs: []
  type: TYPE_NORMAL
- en: pprint(*args, **kwargs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Prints the results returned by `get_analysis` using the pretty print Python
    module (*pprint*)
  prefs: []
  type: TYPE_NORMAL
- en: '**len**()'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Support for invoking `len` on analyzers by actually returning the current length
    of the strategy the analyzer operates on
  prefs: []
  type: TYPE_NORMAL
