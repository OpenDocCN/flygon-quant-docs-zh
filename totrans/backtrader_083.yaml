- en: Sizers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.backtrader.com/docu/sizers/sizers/](https://www.backtrader.com/docu/sizers/sizers/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Smart Staking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A *Strategy* offers methods to trade, namely: `buy`, `sell` and `close`. Let’s
    see the signature of `buy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that `size` has a default value of `None` if the caller does not specify
    it. This is where *Sizers* play an important role:'
  prefs: []
  type: TYPE_NORMAL
- en: '`size=None` requests that the *Strategy* asks its *Sizer* for the actual stake'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This obviously implies that *Strategies* have a *Sizer*: Yes, indeed!. The
    background machinery adds a default sizer to a *Strategy* if the user has not
    added one. The default *Sizer* added to a *strategy* is `SizerFix`. The initial
    lines of the definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is easy to guess that this *Sizer* simply *buys/sells* using a `stake` of
    `1` units (be it shares, contracts, …)
  prefs: []
  type: TYPE_NORMAL
- en: Using *Sizers*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From *Cerebro*
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Sizers* can be added via *Cerebro* with 2 different methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addsizer(sizercls, *args, **kwargs)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Adds a *Sizer* that will be applied to any strategy added to *cerebro*. This
    is, so to to say, the default *Sizer*. Example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`addsizer_byidx(idx, sizercls, *args, **kwargs)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Sizer* will only be added to the *Strategy* referenced by `idx`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This `idx` can be gotten as return value from `addstrategy`. As in:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A default *Sizer* has been added to the system. This one applies to all strategies
    which don’t have a specific *Sizer* assigned
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For *MyStrategy* and after collecting its insertion *idx*, a specific sizer
    (changing the `stake` param) is added
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A 2^(nd) strategy, *MyOtherStrategy*, is added to the system. No specific *Sizer*
    is added for it
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means that:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*MyStrategy* will finally have an internal specific *Sizer*'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*MyOtherStrategy* will get the default sizer'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '*default* doesn’t mean that that the strategies share a single *Sizer* instance.
    Each *strategy* receives a different instance of the *default* sizer'
  prefs: []
  type: TYPE_NORMAL
- en: To share a single instance, the sizer to be shared should be a singleton class.
    How to define one is outside of the scope of *backtrader*
  prefs: []
  type: TYPE_NORMAL
- en: From *Strategy*
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *Strategy* class offers an API: `setsizer` and `getsizer` (and a *property*
    `sizer`) to manage the *Sizer*. The signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def setsizer(self, sizer)`: it takes an already instantiated *Sizer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def getsizer(self)`: returns the current *Sizer* instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sizer` it is the property which can be directly *get/set*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this scenario the *Sizer* can be for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Passed to the strategy as a parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Be set during `__init__` using the property `sizer` or `setsizer` as in:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This would for example allow to create a *Sizer* at the same level as the *cerebro*
    calls are happening and pass it as a parameter to all strategies that go in the
    system, which effectevily allows sharing a *Sizer*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Sizer* Development'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Doing it is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: Subclass from `backtrader.Sizer`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This gives you access to `self.strategy` and `self.broker` although it shouldn’t
    be needed in most cases. Things that can be accessed with the `broker`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: data’s position with `self.strategy.getposition(data)`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: complete portfolio value through `self.broker.getvalue()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice this could of course also be done with `self.strategy.broker.getvalue()`
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Some of the other things are already below as arguments
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Override the method `_getsizing(self, comminfo, cash, data, isbuy)`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`comminfo`: The CommissionInfo instance that contains information about the
    commission for the data and allows calculation of position value, operation cost,
    commision for the operation'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cash`: current available cash in the *broker*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data`: target of the operation'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isbuy`: will be `True` for *buy* operations and `False` for *sell* operations'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This method returns the desired `size` for the *buy/sell* operation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The returned sign is not relevant, ie: if the operation is a *sell* operation
    (`isbuy` will be `False`) the method may return `5` or `-5`. Only the absolute
    value will be used by the *sell* operation.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Sizer` has already gone to the `broker` and requested the *commission information*
    for the given *data*, the actual *cash* level and provides a direct reference
    to the *data* which is the target of the operation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s go for the definition of the `FixedSize` sizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty simple in that the *Sizer* makes no calculations and the parameters
    are just there.
  prefs: []
  type: TYPE_NORMAL
- en: But the mechanism should allow the construction of complex *sizing* (aka *positioning*)
    systems to manage the stakes when entering/exiting the market.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example: **A position rerverser**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This one builds on the existing `FixedSize` to inherit the `params` and overrides
    `_getsizing` to:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the `position` of the *data* via the attribute `broker`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `position.size` to decide if to double the fixed stake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the calculated value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This would remove the burden from the *Strategy* to decide if a position has
    to be reversed or opened, the *Sizer* is in control and can at any time be replaced
    without affecting the logic.
  prefs: []
  type: TYPE_NORMAL
- en: Practical *Sizer* Applicability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Wihtout considering complex sizing algorithms, two different sizers can be
    used to *turn a strategy from Long-Only to Long-Short*. Simply by changing the
    *Sizer* in the *cerebro* execution, the strategy will change behavior. A very
    simple `close` crosses `SMA` algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the strategy doesn’t consider the current *position* (by looking
    at `self.position`) to decide whether a *buy* or *sell* has to actually be done.
    Only the *signal* from the `CrossOver` is considered. The *Sizers* will be in
    charge of everything.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sizer will take care of only returning a *non-zero* size when selling
    if a position is already open:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting it all together (and assuming *backtrader* has already been imported
    and a *data* has been added to the system):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The chart (from the sample included in the sources to test this).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/1fba74a1fe51f47571c5f38989d5ca26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The *Long-Short* version simply changes the *Sizer* to be the `FixedReverser`
    shown above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The output chart.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/168d5183373532bb10e1e57ee4657fde.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of *trades* has duplicated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cash level never goes back to be the *value* because the strategy is *always*
    in the market
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both approaches are anyhow negative, but this is only an example.
  prefs: []
  type: TYPE_NORMAL
- en: '*bt.Sizer* Reference'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: class backtrader.Sizer()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is the base class for *Sizers*. Any *sizer* should subclass this and override
    the `_getsizing` method
  prefs: []
  type: TYPE_NORMAL
- en: 'Member Attribs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`strategy`: will be set by the strategy in which the sizer is working'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Gives access to the entire api of the strategy, for example if the actual data
    position would be needed in `_getsizing`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`broker`: will be set by the strategy in which the sizer is working'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gives access to information some complex sizers may need like portfolio value,
    ..
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _getsizing(comminfo, cash, data, isbuy)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This method has to be overriden by subclasses of Sizer to provide the sizing
    functionality
  prefs: []
  type: TYPE_NORMAL
- en: 'Params:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The method has to return the actual size (an int) to be executed. If `0` is
    returned nothing will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: The absolute value of the returned value will be used
  prefs: []
  type: TYPE_NORMAL
