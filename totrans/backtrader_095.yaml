- en: DateTime Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.backtrader.com/docu/timemgmt/](https://www.backtrader.com/docu/timemgmt/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Up until release *1.5.0*, *backtrader* used a direct approach to time management
    in that whatever datetime was calculated by *data sources* was simply used at
    face value.
  prefs: []
  type: TYPE_NORMAL
- en: And the same for any user input like in the case of the *parameter* `fromdate`
    (or `sessionstart`) which can be given to any *data source*
  prefs: []
  type: TYPE_NORMAL
- en: The approach was fine given the direct control over frozen data sources for
    backtesting. It was easy to assume that the input datetimes had already been taken
    care of before they entered the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'But with 1.5.0, **live** *data sources* are supported and this forces to take
    into account **datetime management**. Such management would not be needed if the
    following were always *true*:'
  prefs: []
  type: TYPE_NORMAL
- en: A trader in New York trades the ES-Mini. The time zone for both in `US/Eastern`
    (or one of the aliases)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A trader in Berlin trades the DAX future. In this case for both the `CET` (or
    `Europe/Berling`) timezone applies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The direct input-output datetime approach from above would work, becase the
    trader, in Berlin for example, could always do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with the direct approach surfaces when the same trader in Berlin
    decides to trade the `ES-Mini`. Because the change to from *DST* happens at different
    point in time in the year and this causes the time difference to be out of sync
    a couple of weeks during the year. The following wouldn’t always work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Operation with timezones
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To solve the aforementioned situations and still remain compatible with the
    direct input-output time approach, `backtrader` offers the end user the following
  prefs: []
  type: TYPE_NORMAL
- en: Datetime Input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a default the platform will not touch the *datetime* provided by a data source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The end-user can override this input by:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a `tzinput` parameter to the data source. This must be an object compatible
    with the `datetime.tzinfo` interface. Most likely the user will provide a `pytz.timezone`
    instance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this decision the time used internally by `backtrader` is considered to
    be in `UTC-like` format, ie:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the data source has already stored it in `UTC` format
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After a conversion through `tzinput`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s not really `UTC` but it’s the reference for the user, hence `UTC-like`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Datetime output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the data feed can automatically determine the timezone for the output, this
    will be the default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This makes sense in the case of live-feeds and especially in use cases like
    the one in which a trader in Berlin (`CET` timezone), trades products with `US/Eastern`
    timezone.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Because the trader gets always the right time and in the example above the *opening*
    time remains constant at `09:30 US/Eastern`, rather than `15:30 CET` most of the
    year, but sometimes `16:30 CET` and sometimes `14:30 CET`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If it cannot be determined, then the output will be whatever was determined
    during input (the `UTC-like`) time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The end user can override and determine the actual timezone for the output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a `tz` parameter to the data source. This must be an object compatible
    with the `datetime.tzinfo` interface. Most likely the user will provide a `pytz.timezone`
    instance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Input fromt the user like for example the parameters `fromdate` or `sessionstart`
    are expected to be in sync with the actual `tz`, be it automatically calculated
    by the *data source*, supplied by the user or left as default (`None`, which means
    direct input-output of *datetime*)
  prefs: []
  type: TYPE_NORMAL
- en: 'With all that in mind let’s recall the Berlin trader, trading in `US/Eastern`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of a *data source* which can automatically determine the output
    timezone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Even less work than above.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously `MyFeed` and `MyFeedAuto` in the example above are just dummy names.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing the only data source included in the distribution which
    can automatically determine the timezone is the one connecting to *Interactive
    Brokers*
  prefs: []
  type: TYPE_NORMAL
