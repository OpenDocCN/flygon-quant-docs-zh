["```py\n `def next(self):\n        # Apply 50% of the portfolio to buy the main asset\n        self.order_target_percent(target=0.5)` \n```", "```py\n`Returns the needed size to meet a cash operation at a given price` \n```", "```py\n`class CommInfoFractional(bt.CommissionInfo):\n    def getsize(self, price, cash):\n  '''Returns fractional size for cash operation @price'''\n        return self.p.leverage * (cash / price)` \n```", "```py\n `if args.fractional:  # use the fractional scheme if requested\n        cerebro.broker.addcommissioninfo(CommInfoFractional())` \n```", "```py\n`$ ./fractional-sizes.py --plot\n2005-02-14,3079.93,3083.38,3065.27,3075.76,0.00\n2005-02-15,3075.20,3091.64,3071.08,3086.95,0.00\n...\n2005-03-21,3052.39,3059.18,3037.80,3038.14,0.00\n2005-03-21,Enter Short\n2005-03-22,Sell Order Completed - Size: -16 @Price: 3040.55 Value: -48648.80 Comm: 0.00\n2005-03-22,Trade Opened  - Size -16 @Price 3040.55\n2005-03-22,3040.55,3053.18,3021.66,3050.44,0.00\n...` \n```", "```py\n`$ ./fractional-sizes.py --fractional --plot\n2005-02-14,3079.93,3083.38,3065.27,3075.76,0.00\n2005-02-15,3075.20,3091.64,3071.08,3086.95,0.00\n...\n2005-03-21,3052.39,3059.18,3037.80,3038.14,0.00\n2005-03-21,Enter Short\n2005-03-22,Sell Order Completed - Size: -16.457437774427774 @Price: 3040.55 Value: -50039.66 Comm: 0.00\n2005-03-22,Trade Opened  - Size -16.457437774427774 @Price 3040.55\n2005-03-22,3040.55,3053.18,3021.66,3050.44,0.00\n...` \n```", "```py\n`#!/usr/bin/env python\n# -*- coding: utf-8; py-indent-offset:4 -*-\n###############################################################################\n# Copyright (C) 2019 Daniel Rodriguez - MIT License\n#  - https://opensource.org/licenses/MIT\n#  - https://en.wikipedia.org/wiki/MIT_License\n###############################################################################\nimport argparse\nimport logging\nimport sys\n\nimport backtrader as bt\n\n# This defines not only the commission info, but some other aspects\n# of a given data asset like the \"getsize\" information from below\n# params = dict(stocklike=True)  # No margin, no multiplier\n\nclass CommInfoFractional(bt.CommissionInfo):\n    def getsize(self, price, cash):\n  '''Returns fractional size for cash operation @price'''\n        return self.p.leverage * (cash / price)\n\nclass St(bt.Strategy):\n    params = dict(\n        p1=10, p2=30,  # periods for crossover\n        ma=bt.ind.SMA,  # moving average to use\n        target=0.5,  # percentage of value to use\n    )\n\n    def __init__(self):\n        ma1, ma2 = [self.p.ma(period=p) for p in (self.p.p1, self.p.p2)]\n        self.cross = bt.ind.CrossOver(ma1, ma2)\n\n    def next(self):\n        self.logdata()\n        if self.cross > 0:\n            self.loginfo('Enter Long')\n            self.order_target_percent(target=self.p.target)\n        elif self.cross < 0:\n            self.loginfo('Enter Short')\n            self.order_target_percent(target=-self.p.target)\n\n    def notify_trade(self, trade):\n        if trade.justopened:\n            self.loginfo('Trade Opened  - Size {} @Price {}',\n                         trade.size, trade.price)\n        elif trade.isclosed:\n            self.loginfo('Trade Closed  - Profit {}', trade.pnlcomm)\n\n        else:  # trade updated\n            self.loginfo('Trade Updated - Size {} @Price {}',\n                         trade.size, trade.price)\n\n    def notify_order(self, order):\n        if order.alive():\n            return\n\n        otypetxt = 'Buy ' if order.isbuy() else 'Sell'\n        if order.status == order.Completed:\n            self.loginfo(\n                ('{} Order Completed - '\n                 'Size: {} @Price: {} '\n                 'Value: {:.2f} Comm: {:.2f}'),\n                otypetxt, order.executed.size, order.executed.price,\n                order.executed.value, order.executed.comm\n            )\n        else:\n            self.loginfo('{} Order rejected', otypetxt)\n\n    def loginfo(self, txt, *args):\n        out = [self.datetime.date().isoformat(), txt.format(*args)]\n        logging.info(','.join(out))\n\n    def logerror(self, txt, *args):\n        out = [self.datetime.date().isoformat(), txt.format(*args)]\n        logging.error(','.join(out))\n\n    def logdebug(self, txt, *args):\n        out = [self.datetime.date().isoformat(), txt.format(*args)]\n        logging.debug(','.join(out))\n\n    def logdata(self):\n        txt = []\n        txt += ['{:.2f}'.format(self.data.open[0])]\n        txt += ['{:.2f}'.format(self.data.high[0])]\n        txt += ['{:.2f}'.format(self.data.low[0])]\n        txt += ['{:.2f}'.format(self.data.close[0])]\n        txt += ['{:.2f}'.format(self.data.volume[0])]\n        self.loginfo(','.join(txt))\n\ndef run(args=None):\n    args = parse_args(args)\n\n    cerebro = bt.Cerebro()\n\n    data = bt.feeds.BacktraderCSVData(dataname=args.data)\n    cerebro.adddata(data)  # create and add data feed\n\n    cerebro.addstrategy(St)  # add the strategy\n\n    cerebro.broker.set_cash(args.cash)  # set broker cash\n\n    if args.fractional:  # use the fractional scheme if requested\n        cerebro.broker.addcommissioninfo(CommInfoFractional())\n\n    cerebro.run()  # execute\n\n    if args.plot:  # Plot if requested to\n        cerebro.plot(**eval('dict(' + args.plot + ')'))\n\ndef logconfig(pargs):\n    if pargs.quiet:\n        verbose_level = logging.ERROR\n    else:\n        verbose_level = logging.INFO - pargs.verbose * 10  # -> DEBUG\n\n    logger = logging.getLogger()\n    for h in logger.handlers:  # Remove all loggers from root\n        logger.removeHandler(h)\n\n    stream = sys.stdout if not pargs.stderr else sys.stderr  # choose stream\n\n    logging.basicConfig(\n        stream=stream,\n        format=\"%(message)s\",  # format=\"%(levelname)s: %(message)s\",\n        level=verbose_level,\n    )\n\ndef parse_args(pargs=None):\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n        description='Fractional Sizes with CommInfo',\n    )\n\n    pgroup = parser.add_argument_group('Data Options')\n    parser.add_argument('--data', default='../../datas/2005-2006-day-001.txt',\n                        help='Data to read in')\n\n    pgroup = parser.add_argument_group(title='Broker Arguments')\n    pgroup.add_argument('--cash', default=100000.0, type=float,\n                        help='Starting cash to use')\n\n    pgroup.add_argument('--fractional', action='store_true',\n                        help='Use fractional commission info')\n\n    pgroup = parser.add_argument_group(title='Plotting Arguments')\n    pgroup.add_argument('--plot', default='', nargs='?', const='{}',\n                        metavar='kwargs', help='kwargs: \"k1=v1,k2=v2,...\"')\n\n    pgroup = parser.add_argument_group('Verbosity Options')\n    pgroup.add_argument('--stderr', action='store_true',\n                        help='Log to stderr, else to stdout')\n    pgroup = pgroup.add_mutually_exclusive_group()\n    pgroup.add_argument('--quiet', '-q', action='store_true',\n                        help='Silent (errors will be reported)')\n    pgroup.add_argument('--verbose', '-v', action='store_true',\n                        help='Increase verbosity level')\n\n    # Parse and process some args\n    pargs = parser.parse_args(pargs)\n    logconfig(pargs)  # config logging\n    return pargs\n\nif __name__ == '__main__':\n    run()` \n```"]