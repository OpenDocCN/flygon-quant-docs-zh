["```py\n`./vanktharp-coinflip.py --years 1985-1990 --fixedsize --sizer stake=1 --iterations 1 --plot\n\n**** Iteration:    1\n-- PNL: 10482.00\n--   Trades 49 - Won 22 - %_Won: 0.45\n**** Summary of Runs\n-- Total       :        1\n-- Won         :        1\n-- % Won       : 1.00\n**** Summary of Trades\n-- Total       :       49\n-- Total Won   :       22\n-- % Total Won : 0.45` \n```", "```py\n`$ ./vanktharp-coinflip.py --years 1985-1990 --percrisk --sizer percrisk=0.01 --iterations 100 --scatter\n**** Iteration:    1\n-- PNL: -18218.00\n--   Trades 60 - Won 24 - %_Won: 0.40\n**** Iteration:    2\n...\n...\n**** Iteration:  100\n-- PNL: 111366.00\n--   Trades 50 - Won 26 - %_Won: 0.52\n**** Summary of Runs\n-- Total       :      100\n-- Won         :       50\n-- % Won       : 0.50\n**** Summary of Trades\n-- Total       :     5504\n-- Total Won   :     2284\n-- % Total Won : 0.41` \n```", "```py\n`#!/usr/bin/env python\n# -*- coding: utf-8; py-indent-offset:4 -*-\n###############################################################################\n# Copyright (C) 2019 Daniel Rodriguez - MIT License\n#  - https://opensource.org/licenses/MIT\n#  - https://en.wikipedia.org/wiki/MIT_License\n###############################################################################\nimport argparse\nimport random\n\nimport pandas as pd\n\nimport backtrader as bt\n\ndef read_dataframe(filename, years):\n    colnames = ['ticker', 'period', 'date', 'time',\n                'open', 'high', 'low', 'close', 'volume', 'openinterest']\n\n    colsused = ['date',\n                'open', 'high', 'low', 'close', 'volume', 'openinterest']\n\n    df = pd.read_csv(filename,\n                     skiprows=1,  # using own column names, skip header\n                     names=colnames,\n                     usecols=colsused,\n                     parse_dates=['date'],\n                     index_col='date')\n\n    if years:  # year or year range specified\n        ysplit = years.split('-')\n\n        # left side limit\n        mask = df.index >= ((ysplit[0] or '0001') + '-01-01')  # support -YYYY\n\n        # right side liit\n        if len(ysplit) > 1:  # multiple or open ended (YYYY-ZZZZ or YYYY-)\n            if ysplit[1]:  # open ended if not years[1] (YYYY- format)\n                mask &= df.index <= (ysplit[1] + '-12-31')\n        else:  # single year specified YYYY\n            mask &= df.index <= (ysplit[0] + '-12-31')\n\n        df = df.loc[mask]  # select the given date range\n\n    return df\n\n# DEFAULTS - CAN BE CHANGED VIA COMMAND LINE OPTIONS\nCOMMINFO_DEFAULT = dict(\n    stocklike=False,  # Futures-like\n    commtype=bt.CommissionInfo.COMM_FIXED,  # fixed price per asset\n    commission=2.0,  # Standard IB Price for futures\n    mult=1000.0,  # multiplier\n    margin=2000.0,  # $50 x 50 => $2500\n)\n\nclass PercentRiskSizer(bt.Sizer):\n  '''Sizer modeling the Percentage Risk sizing model of Van K. Tharp'''\n    params = dict(percrisk=0.01)  # 1% percentage risk\n\n    def _getsizing(self, comminfo, cash, data, isbuy):\n        # Risk per 1 contract\n        risk = comminfo.p.mult * self.strategy.stoptrailer.stop_dist[0]\n        # % of account value to risk\n        torisk = self.broker.get_value() * self.p.percrisk\n        return torisk // risk  # size to risk\n\nclass CoinFlip(bt.Indicator):\n    lines = ('coinflip',)\n    HEAD, TAIL = 1, 0\n\n    def next(self):\n        self.l.coinflip[0] = 0.5  # midway\n        pass\n\n    def flip(self):\n        # self.l.coinflip[0] = cf = random.randrage(-1, 2, 2)  # -1 or 1\n        self.l.coinflip[0] = cf = random.randint(0, 1)\n        return cf\n\n    def head(self, val=None):\n        if val is None:\n            return self.lines[0] == self.HEAD\n\n        return val == self.HEAD\n\nclass StopTrailer(bt.Indicator):\n    _nextforce = True  # force system into step by step calcs\n\n    lines = ('stop_long', 'stop_short',)\n    plotinfo = dict(subplot=False, plotlinelabels=True)\n\n    params = dict(\n        atrperiod=14,\n        emaperiod=10,\n        stopfactor=3.0,\n    )\n\n    def __init__(self):\n        self.strat = self._owner  # alias for clarity\n\n        # Volatility which determines stop distance\n        atr = bt.ind.ATR(self.data, period=self.p.atrperiod)\n        emaatr = bt.ind.EMA(atr, period=self.p.emaperiod)\n        self.stop_dist = emaatr * self.p.stopfactor\n\n        # Running stop price calc, applied in next according to market pos\n        self.s_l = self.data - self.stop_dist\n        self.s_s = self.data + self.stop_dist\n\n    def next(self):\n        # When entering the market, the stop has to be set\n        if self.strat.entering > 0:  # entering long\n            self.l.stop_long[0] = self.s_l[0]\n        elif self.strat.entering < 0:  # entering short\n            self.l.stop_short[0] = self.s_s[0]\n\n        else:  # In the market, adjust stop only in the direction of the trade\n            if self.strat.position.size > 0:\n                self.l.stop_long[0] = max(self.s_l[0], self.l.stop_long[-1])\n            elif self.strat.position.size < 0:\n                self.l.stop_short[0] = min(self.s_s[0], self.l.stop_short[-1])\n\nclass St1(bt.Strategy):\n    SHORT, NONE, LONG = -1, 0, 1\n\n    params = dict(\n        atrperiod=14,  # measure volatility over x days\n        emaperiod=10,  # smooth out period for atr volatility\n        stopfactor=3.0,  # actual stop distance for smoothed atr\n        verbose=False,  # print out debug info\n        samebar=True,  # close and re-open on samebar\n    )\n\n    def __init__(self):\n        self.coinflip = CoinFlip()\n\n        # Trailing Stop Indicator\n        self.stoptrailer = st = StopTrailer(atrperiod=self.p.atrperiod,\n                                            emaperiod=self.p.emaperiod,\n                                            stopfactor=self.p.stopfactor)\n\n        # Exit Criteria (Stop Trail) for long / short positions\n        self.exit_long = bt.ind.CrossDown(self.data,\n                                          st.stop_long, plotname='Exit Long')\n        self.exit_short = bt.ind.CrossUp(self.data,\n                                         st.stop_short, plotname='Exit Short')\n\n    def start(self):\n        self.entering = 0\n        self.start_val = self.broker.get_value()\n\n    def stop(self):\n        self.stop_val = self.broker.get_value()\n        self.pnl_val = self.stop_val - self.start_val\n        self.log('Start Value: {:.2f}', self.start_val)\n        self.log('Final Value: {:.2f}', self.stop_val)\n        self.log('PNL   Value: {:.2f}', self.pnl_val)\n\n    def notify_trade(self, trade):\n        if trade.size > 0:\n            self.log('Long  Entry at: {:.2f}', trade.price)\n        elif trade.size < 0:\n            self.log('Short Entry at: {:.2f}', trade.price)\n        else:  # not trade.size - trade is over\n            self.log('Trade PNL: {:.2f}', trade.pnlcomm)\n\n    def next(self):\n        self.logdata()\n\n        # logic\n        closing = None\n        if self.position.size > 0:  # In the market - Long\n            self.log('Long Stop Price: {:.2f}', self.stoptrailer.stop_long[0])\n            if self.exit_long:\n                closing = self.close()\n\n        elif self.position.size < 0:  # In the market - Short\n            self.log('Short Stop Price {:.2f}', self.stoptrailer.stop_short[0])\n            if self.exit_short:\n                closing = self.close()\n\n        self.entering = self.NONE\n        if not self.position or (closing and self.p.samebar):\n            # Not in the market or closing pos and reenter in samebar\n            if self.coinflip.flip():\n                self.entering = self.LONG if self.buy() else self.NONE\n            else:\n                self.entering = self.SHORT if self.sell() else self.NONE\n\n    def logdata(self):\n        if self.p.verbose:  # logging\n            txt = []\n            txt += ['{:.2f}'.format(self.position.size)]\n            txt += ['{:.2f}'.format(self.data.open[0])]\n            txt += ['{:.2f}'.format(self.data.high[0])]\n            txt += ['{:.2f}'.format(self.data.low[0])]\n            txt += ['{:.2f}'.format(self.data.close[0])]\n            self.log(','.join(txt))\n\n    def log(self, txt, *args):\n        if self.p.verbose:\n            out = [self.datetime.date().isoformat(), txt.format(*args)]\n            print(','.join(out))\n\ndef runstrat(args):\n    cerebro = bt.Cerebro()\n\n    # Data feed kwargs\n    dataargs = dict(dataname=read_dataframe(args.data, args.years))\n    dataargs.update(eval('dict(' + args.dargs + ')'))\n    cerebro.adddata(bt.feeds.PandasData(**dataargs))\n\n    # Strategy\n    cerebro.addstrategy(St1, **eval('dict(' + args.strat + ')'))\n\n    # Broker\n    brokerargs = dict(cash=args.cash)\n    brokerargs.update(eval('dict(' + args.broker + ')'))\n    cerebro.broker = bt.brokers.BackBroker(**brokerargs)\n\n    # Commission\n    commargs = COMMINFO_DEFAULT\n    commargs.update(eval('dict(' + args.commission + ')'))\n    cerebro.broker.setcommission(**commargs)\n\n    # Sizer\n    szcls = PercentRiskSizer if args.percrisk else bt.sizers.FixedSize\n    cerebro.addsizer(szcls, **(eval('dict(' + args.sizer + ')')))\n\n    # Analyze the trades\n    cerebro.addanalyzer(bt.analyzers.TradeAnalyzer, _name='trades')\n\n    # Execute\n    strats = cerebro.run(**eval('dict(' + args.cerebro + ')'))\n\n    if args.plot:  # Plot if requested to\n        cerebro.plot(**eval('dict(' + args.plot + ')'))\n\n    return strats[0]\n\ndef run(args=None):\n    args = parse_args(args)\n\n    results = []\n    sum_won_trades = 0\n    sum_total_trades = 0\n\n    for i in range(0, args.iterations):\n        strat = runstrat(args)\n        pnl = strat.pnl_val\n        results.append(pnl)\n        trades = strat.analyzers.trades.get_analysis()\n\n        print('**** Iteration: {:4d}'.format(i + 1))\n        print('-- PNL: {:.2f}'.format(pnl))\n        total_trades = trades.total.closed\n        total_won = trades.won.total\n        perc_won = total_won / total_trades\n        print('--   Trades {} - Won {} - %_Won: {:.2f}'.format(\n            total_trades, total_won, perc_won))\n\n        sum_won_trades += total_won\n        sum_total_trades += total_trades\n\n    total = len(results)\n    won = sum(1 for x in results if x > 0)\n    print('**** Summary of Runs')\n    print('-- Total       : {:8d}'.format(total))\n    print('-- Won         : {:8d}'.format(won))\n    print('-- % Won       : {:.2f}'.format(won / total))\n\n    perc_won = sum_won_trades / sum_total_trades\n    print('**** Summary of Trades')\n    print('-- Total       : {:8d}'.format(sum_total_trades))\n    print('-- Total Won   : {:8d}'.format(sum_won_trades))\n    print('-- % Total Won : {:.2f}'.format(perc_won))\n\n    if args.scatter:\n        import numpy as np\n        import matplotlib.pyplot as plt\n        x = np.linspace(min(results), max(results), num=len(results))\n        y = np.asarray(results)\n        plt.scatter(x, y)\n        plt.show()\n\ndef parse_args(pargs=None):\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n        description='Van K. Tharp/Basso Random Entry Scenario',\n    )\n\n    parser.add_argument('--iterations', default=1, type=int,\n                        help='Number of iterations to run the system')\n\n    pgroup = parser.add_argument_group(title='Data Options')\n    pgroup.add_argument('--data', default='cl-day-001.txt',\n                        help='Data to read in')\n\n    pgroup.add_argument('--years', default='',\n                        help='Formats: YYYY-ZZZZ / YYYY / YYYY- / -ZZZZ')\n\n    parser.add_argument('--dargs', required=False, default='',\n                        metavar='kwargs', help='kwargs in key=value format')\n\n    pgroup = parser.add_argument_group(title='Cerebro Arguments')\n    pgroup.add_argument('--cerebro', default='', metavar='kwargs',\n                        help='Cerebro kwargs in key=value format')\n\n    pgroup = parser.add_argument_group(title='Commission Arguments')\n    pgroup.add_argument('--commission', default=str(COMMINFO_DEFAULT),\n                        metavar='kwargs',\n                        help='CommInfo kwargs in key=value format')\n\n    pgroup = parser.add_argument_group(title='Broker Arguments')\n    pgroup.add_argument('--broker', default='', metavar='kwargs',\n                        help='Broker kwargs in key=value format')\n\n    pgroup.add_argument('--cash', default=1000000.0, type=float,\n                        help='Default cash')\n\n    pgroup = parser.add_argument_group(title='Strategy Arguments')\n    pgroup.add_argument('--strat', default='', metavar='kwargs',\n                        help='Strategy kwargs in key=value format')\n\n    pgroup = parser.add_argument_group(title='Sizer Options')\n    pgroup.add_argument('--sizer', default='', metavar='kwargs',\n                        help='Sizer kwargs in key=value format')\n\n    pgroup = pgroup.add_mutually_exclusive_group()\n    pgroup.add_argument('--percrisk', action='store_true',\n                        help='Use Percrisk Sizer')\n\n    pgroup.add_argument('--fixedsize', action='store_true',\n                        help='Use Fixed Statke Sizer')\n\n    pgroup = parser.add_argument_group(title='Plotting Options')\n    pgroup.add_argument('--plot', default='', nargs='?', const='{}',\n                        metavar='kwargs', help='kwargs in key=value format')\n\n    pgroup.add_argument('--scatter', action='store_true',\n                        help='Plot a scatter diagram of PNL results')\n\n    return parser.parse_args(pargs)\n\nif __name__ == '__main__':\n    run()` \n```"]