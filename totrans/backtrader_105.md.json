["```py\n`date, open, high, low, close, volume, npy\n2001-12-31, 1.0, 1.0, 1.0, 1.0, 0.5, 3.0\n2002-01-31, 2.0, 2.5, 1.1, 1.2, 3.0, 5.0\n...` \n```", "```py\n`class NetPayOutData(bt.feeds.GenericCSVData):\n    lines = ('npy',)  # add a line containing the net payout yield\n    params = dict(\n        npy=6,  # npy field is in the 6th column (0 based index)\n        dtformat='%Y-%m-%d',  # fix date format a yyyy-mm-dd\n        timeframe=bt.TimeFrame.Months,  # fixed the timeframe\n        openinterest=-1,  # -1 indicates there is no openinterest field\n    )` \n```", "```py\n`class St(bt.Strategy):\n    params = dict(\n        selcperc=0.10,  # percentage of stocks to select from the universe\n        rperiod=1,  # period for the returns calculation, default 1 period\n        vperiod=36,  # lookback period for volatility - default 36 periods\n        mperiod=12,  # lookback period for momentum - default 12 periods\n        reserve=0.05  # 5% reserve capital\n    )` \n```", "```py\n `def log(self, arg):\n        print('{}  {}'.format(self.datetime.date(), arg))` \n```", "```py\n `def __init__(self):\n        # calculate 1st the amount of stocks that will be selected\n        self.selnum = int(len(self.datas) * self.p.selcperc)\n\n        # allocation perc per stock\n        # reserve kept to make sure orders are not rejected due to\n        # margin. Prices are calculated when known (close), but orders can only\n        # be executed next day (opening price). Price can gap upwards\n        self.perctarget = (1.0 - self.p.reserve) % self.selnum` \n```", "```py\n `# returns, volatilities and momentums\n        rs = [bt.ind.PctChange(d, period=self.p.rperiod) for d in self.datas]\n        vs = [bt.ind.StdDev(ret, period=self.p.vperiod) for ret in rs]\n        ms = [bt.ind.ROC(d, period=self.p.mperiod) for d in self.datas]\n\n        # simple rank formula: (momentum * net payout) / volatility\n        # the highest ranked: low vol, large momentum, large payout\n        self.ranks = {d: d.npy * m / v for d, v, m in zip(self.datas, vs, ms)}` \n```", "```py\n `def next(self):\n        # sort data and current rank\n        ranks = sorted(\n            self.ranks.items(),  # get the (d, rank), pair\n            key=lambda x: x[1][0],  # use rank (elem 1) and current time \"0\"\n            reverse=True,  # highest ranked 1st ... please\n        )` \n```", "```py\n `# put top ranked in dict with data as key to test for presence\n        rtop = dict(ranks[:self.selnum])\n\n        # For logging purposes of stocks leaving the portfolio\n        rbot = dict(ranks[self.selnum:])` \n```", "```py\n `# prepare quick lookup list of stocks currently holding a position\n        posdata = [d for d, pos in self.getpositions().items() if pos]` \n```", "```py\n `# remove those no longer top ranked\n        # do this first to issue sell orders and free cash\n        for d in (d for d in posdata if d not in rtop):\n            self.log('Exit {} - Rank {:.2f}'.format(d._name, rbot[d][0]))\n            self.order_target_percent(d, target=0.0)` \n```", "```py\n `# rebalance those already top ranked and still there\n        for d in (d for d in posdata if d in rtop):\n            self.log('Rebal {} - Rank {:.2f}'.format(d._name, rtop[d][0]))\n            self.order_target_percent(d, target=self.perctarget)\n            del rtop[d]  # remove it, to simplify next iteration` \n```", "```py\n `# issue a target order for the newly top ranked stocks\n        # do this last, as this will generate buy orders consuming cash\n        for d in rtop:\n            self.log('Enter {} - Rank {:.2f}'.format(d._name, rtop[d][0]))\n            self.order_target_percent(d, target=self.perctarget)` \n```", "```py\n`def run(args=None):\n    args = parse_args(args)\n\n    cerebro = bt.Cerebro()\n\n    # Data feed kwargs\n    dkwargs = dict(**eval('dict(' + args.dargs + ')'))\n\n    # Parse from/to-date\n    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'\n    if args.fromdate:\n        fmt = dtfmt + tmfmt * ('T' in args.fromdate)\n        dkwargs['fromdate'] = datetime.datetime.strptime(args.fromdate, fmt)\n\n    if args.todate:\n        fmt = dtfmt + tmfmt * ('T' in args.todate)\n        dkwargs['todate'] = datetime.datetime.strptime(args.todate, fmt)\n\n    # add all the data files available in the directory datadir\n    for fname in glob.glob(os.path.join(args.datadir, '*')):\n        data = NetPayOutData(dataname=fname, **dkwargs)\n        cerebro.adddata(data)\n\n    # add strategy\n    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))\n\n    # set the cash\n    cerebro.broker.setcash(args.cash)\n\n    cerebro.run()  # execute it all\n\n    # Basic performance evaluation ... final value ... minus starting cash\n    pnl = cerebro.broker.get_value() - args.cash\n    print('Profit ... or Loss: {:.2f}'.format(pnl))` \n```", "```py\n`import argparse\nimport datetime\nimport glob\nimport os.path\n\nimport backtrader as bt\n\nclass NetPayOutData(bt.feeds.GenericCSVData):\n    lines = ('npy',)  # add a line containing the net payout yield\n    params = dict(\n        npy=6,  # npy field is in the 6th column (0 based index)\n        dtformat='%Y-%m-%d',  # fix date format a yyyy-mm-dd\n        timeframe=bt.TimeFrame.Months,  # fixed the timeframe\n        openinterest=-1,  # -1 indicates there is no openinterest field\n    )\n\nclass St(bt.Strategy):\n    params = dict(\n        selcperc=0.10,  # percentage of stocks to select from the universe\n        rperiod=1,  # period for the returns calculation, default 1 period\n        vperiod=36,  # lookback period for volatility - default 36 periods\n        mperiod=12,  # lookback period for momentum - default 12 periods\n        reserve=0.05  # 5% reserve capital\n    )\n\n    def log(self, arg):\n        print('{}  {}'.format(self.datetime.date(), arg))\n\n    def __init__(self):\n        # calculate 1st the amount of stocks that will be selected\n        self.selnum = int(len(self.datas) * self.p.selcperc)\n\n        # allocation perc per stock\n        # reserve kept to make sure orders are not rejected due to\n        # margin. Prices are calculated when known (close), but orders can only\n        # be executed next day (opening price). Price can gap upwards\n        self.perctarget = (1.0 - self.p.reserve) / self.selnum\n\n        # returns, volatilities and momentums\n        rs = [bt.ind.PctChange(d, period=self.p.rperiod) for d in self.datas]\n        vs = [bt.ind.StdDev(ret, period=self.p.vperiod) for ret in rs]\n        ms = [bt.ind.ROC(d, period=self.p.mperiod) for d in self.datas]\n\n        # simple rank formula: (momentum * net payout) / volatility\n        # the highest ranked: low vol, large momentum, large payout\n        self.ranks = {d: d.npy * m / v for d, v, m in zip(self.datas, vs, ms)}\n\n    def next(self):\n        # sort data and current rank\n        ranks = sorted(\n            self.ranks.items(),  # get the (d, rank), pair\n            key=lambda x: x[1][0],  # use rank (elem 1) and current time \"0\"\n            reverse=True,  # highest ranked 1st ... please\n        )\n\n        # put top ranked in dict with data as key to test for presence\n        rtop = dict(ranks[:self.selnum])\n\n        # For logging purposes of stocks leaving the portfolio\n        rbot = dict(ranks[self.selnum:])\n\n        # prepare quick lookup list of stocks currently holding a position\n        posdata = [d for d, pos in self.getpositions().items() if pos]\n\n        # remove those no longer top ranked\n        # do this first to issue sell orders and free cash\n        for d in (d for d in posdata if d not in rtop):\n            self.log('Leave {} - Rank {:.2f}'.format(d._name, rbot[d][0]))\n            self.order_target_percent(d, target=0.0)\n\n        # rebalance those already top ranked and still there\n        for d in (d for d in posdata if d in rtop):\n            self.log('Rebal {} - Rank {:.2f}'.format(d._name, rtop[d][0]))\n            self.order_target_percent(d, target=self.perctarget)\n            del rtop[d]  # remove it, to simplify next iteration\n\n        # issue a target order for the newly top ranked stocks\n        # do this last, as this will generate buy orders consuming cash\n        for d in rtop:\n            self.log('Enter {} - Rank {:.2f}'.format(d._name, rtop[d][0]))\n            self.order_target_percent(d, target=self.perctarget)\n\ndef run(args=None):\n    args = parse_args(args)\n\n    cerebro = bt.Cerebro()\n\n    # Data feed kwargs\n    dkwargs = dict(**eval('dict(' + args.dargs + ')'))\n\n    # Parse from/to-date\n    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'\n    if args.fromdate:\n        fmt = dtfmt + tmfmt * ('T' in args.fromdate)\n        dkwargs['fromdate'] = datetime.datetime.strptime(args.fromdate, fmt)\n\n    if args.todate:\n        fmt = dtfmt + tmfmt * ('T' in args.todate)\n        dkwargs['todate'] = datetime.datetime.strptime(args.todate, fmt)\n\n    # add all the data files available in the directory datadir\n    for fname in glob.glob(os.path.join(args.datadir, '*')):\n        data = NetPayOutData(dataname=fname, **dkwargs)\n        cerebro.adddata(data)\n\n    # add strategy\n    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))\n\n    # set the cash\n    cerebro.broker.setcash(args.cash)\n\n    cerebro.run()  # execute it all\n\n    # Basic performance evaluation ... final value ... minus starting cash\n    pnl = cerebro.broker.get_value() - args.cash\n    print('Profit ... or Loss: {:.2f}'.format(pnl))\n\ndef parse_args(pargs=None):\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n        description=('Rebalancing with the Conservative Formula'),\n    )\n\n    parser.add_argument('--datadir', required=True,\n                        help='Directory with data files')\n\n    parser.add_argument('--dargs', default='',\n                        metavar='kwargs', help='kwargs in k1=v1,k2=v2 format')\n\n    # Defaults for dates\n    parser.add_argument('--fromdate', required=False, default='',\n                        help='Date[time] in YYYY-MM-DD[THH:MM:SS] format')\n\n    parser.add_argument('--todate', required=False, default='',\n                        help='Date[time] in YYYY-MM-DD[THH:MM:SS] format')\n\n    parser.add_argument('--cerebro', required=False, default='',\n                        metavar='kwargs', help='kwargs in k1=v1,k2=v2 format')\n\n    parser.add_argument('--cash', default=1000000.0, type=float,\n                        metavar='kwargs', help='kwargs in k1=v1,k2=v2 format')\n\n    parser.add_argument('--strat', required=False, default='',\n                        metavar='kwargs', help='kwargs in k1=v1,k2=v2 format')\n\n    return parser.parse_args(pargs)\n\nif __name__ == '__main__':\n    run()` \n```"]