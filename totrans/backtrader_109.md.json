["```py\n`class Momentum(bt.Indicator):\n    lines = ('trend',)\n    params = (('period', 90),)` \n```", "```py\n`class Momentum(bt.Indicator):\n    lines = ('trend',)\n    params = dict(period=90)  # or params = {'period': 90}` \n```", "```py\n`class Momentum(bt.Indicator):\n    lines = ('trend',)\n    params = (('period', 90),)\n\n    def __init__(self):\n        self.addminperiod(self.params.period)\n\n    def next(self):\n        returns = np.log(self.data.get(size=self.p.period))\n        x = np.arange(len(returns))\n        slope, _, rvalue, _, _ = linregress(x, returns)\n        annualized = (1 + slope) ** 252\n        self.lines.trend[0] = annualized * (rvalue ** 2)` \n```", "```py\n`class Momentum(bt.ind.PeriodN):\n    lines = ('trend',)\n    params = dict(period=50)\n\n    def next(self):\n        ...` \n```", "```py\n`def momentum_func(the_array):\n    r = np.log(the_array)\n    slope, _, rvalue, _, _ = linregress(np.arange(len(r)), r)\n    annualized = (1 + slope) ** 252\n    return annualized * (rvalue ** 2)\n\nclass Momentum(bt.ind.OperationN):\n    lines = ('trend',)\n    params = dict(period=50)\n    func = momentum_func` \n```", "```py\n`class Strategy(bt.Strategy):\n    def __init__(self):\n        self.i = 0\n        self.inds = {}\n        self.spy = self.datas[0]\n        self.stocks = self.datas[1:]\n\n        self.spy_sma200 = bt.indicators.SimpleMovingAverage(self.spy.close,\n                                                            period=200)\n        for d in self.stocks:\n            self.inds[d] = {}\n            self.inds[d][\"momentum\"] = Momentum(d.close,\n                                                period=90)\n            self.inds[d][\"sma100\"] = bt.indicators.SimpleMovingAverage(d.close,\n                                                                       period=100)\n            self.inds[d][\"atr20\"] = bt.indicators.ATR(d,\n                                                      period=20)` \n```", "```py\n`class Strategy(bt.Strategy):\n    params = dict(\n        momentum=Momentum,  # parametrize the momentum and its period\n        momentum_period=90,\n\n        movav=bt.ind.SMA,  # parametrize the moving average and its periods\n        idx_period=200,\n        stock_period=100,\n\n        volatr=bt.ind.ATR,  # parametrize the volatility and its period\n        vol_period=20,\n    )\n\n    def __init__(self):\n        # self.i = 0  # See below as to why the counter is commented out\n        self.inds = collections.defaultdict(dict)  # avoid per data dct in for\n\n        # Use \"self.data0\" (or self.data) in the script to make the naming not\n        # fixed on this being a \"spy\" strategy. Keep things generic\n        # self.spy = self.datas[0]\n        self.stocks = self.datas[1:]\n\n        # Again ... remove the name \"spy\"\n        self.idx_mav = self.p.movav(self.data0, period=self.p.idx_period)\n        for d in self.stocks:\n            self.inds[d]['mom'] = self.p.momentum(d, period=self.momentum_period)\n            self.inds[d]['mav'] = self.p.movav(d, period=self.p.stock_period)\n            self.inds[d]['vol'] = self.p.volatr(d, period=self.p.vol_period)` \n```", "```py\n `def next(self):\n        if self.i % 5 == 0:\n            self.rebalance_portfolio()\n        if self.i % 10 == 0:\n            self.rebalance_positions()\n        self.i += 1` \n```", "```py\n `def next(self):\n        l = len(self)\n        if l % 5 == 0:\n            self.rebalance_portfolio()\n        if l % 10 == 0:\n            self.rebalance_positions()` \n```", "```py\n `def prenext(self):\n        # call next() even when data is not available for all tickers\n        self.next()` \n```", "```py\n `def next(self):\n        if self.i % 5 == 0:\n            self.rebalance_portfolio()\n        ...` \n```", "```py\n `def prenext(self):\n        # call next() even when data is not available for all tickers\n        self.next()\n\n    def next(self):\n        d_with_len = [d for d in self.datas if len(d)]\n        ...` \n```", "```py\n `def __init__(self):\n        ...\n        self.d_with_len = []\n\n    def prenext(self):\n        # Populate d_with_len\n        self.d_with_len = [d for d in self.datas if len(d)]\n        # call next() even when data is not available for all tickers\n        self.next()\n\n    def nextstart(self):\n        # This is called exactly ONCE, when next is 1st called and defaults to\n        # call `next`\n        self.d_with_len = self.datas  # all data sets fulfill the guarantees now\n\n        self.next()  # delegate the work to next\n\n    def next(self):\n        # we can now always work with self.d_with_len with no calculation\n        ...` \n```", "```py\n`class Strategy(bt.Strategy):\n    params = dict(\n       ...\n       rebal_weekday=5,  # rebalance 5 is Friday\n    )\n\n    def __init__(self):\n        ...\n        self.add_timer(\n            when=bt.Timer.SESSION_START,\n            weekdays=[self.p.rebal_weekday],\n            weekcarry=True,  # if a day isn't there, execute on the next\n        )\n        ...` \n```", "```py\n`def notify_timer(self, timer, when, *args, **kwargs):\n    self.rebalance_portfolio()` \n```", "```py\n `if self.spy < self.spy_sma200:\n            return` \n```", "```py\n `def __init__(self):\n        ...\n        self.spy_filter = self.spe < self.spy_sma200` \n```", "```py\n `if self.spy_filter:\n            return` \n```", "```py\n `# sell stocks based on criteria\n        for i, d in enumerate(self.rankings):\n            if self.getposition(self.data).size:\n                if i > num_stocks * 0.2 or d < self.inds[d][\"sma100\"]:\n                    self.close(d)` \n```", "```py\n `# sell stocks based on criteria\n        for i, d in enumerate(self.rankings):\n            if self.getposition(self.data).size:\n                if i > num_stocks * 0.2 or self.inds[d]['sma_signal']:\n                    self.close(d)` \n```"]