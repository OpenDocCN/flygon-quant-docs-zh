["```py\n`class BaseStrategy(bt.Strategy):\n    params = dict(\n        fast_ma=10,\n        slow_ma=20,\n    )\n\n    def __init__(self):\n        # omitting a data implies self.datas[0] (aka self.data and self.data0)\n        fast_ma = bt.ind.EMA(period=self.p.fast_ma)\n        slow_ma = bt.ind.EMA(period=self.p.slow_ma)\n        # our entry point\n        self.crossup = bt.ind.CrossUp(fast_ma, slow_ma)` \n```", "```py\n`class ManualStopOrStopTrail(BaseStrategy):\n    params = dict(\n        stop_loss=0.02,  # price is 2% less than the entry point\n        trail=False,\n    )\n\n    def notify_order(self, order):\n        if not order.status == order.Completed:\n            return  # discard any other notification\n\n        if not self.position:  # we left the market\n            print('SELL@price: {:.2f}'.format(order.executed.price))\n            return\n\n        # We have entered the market\n        print('BUY @price: {:.2f}'.format(order.executed.price))\n\n        if not self.p.trail:\n            stop_price = order.executed.price * (1.0 - self.p.stop_loss)\n            self.sell(exectype=bt.Order.Stop, price=stop_price)\n        else:\n            self.sell(exectype=bt.Order.StopTrail, trailamount=self.p.trail)\n\n    def next(self):\n        if not self.position and self.crossup > 0:\n            # not in the market and signal triggered\n            self.buy()` \n```", "```py\n`$ ./stop-loss-approaches.py manual --plot\nBUY @price: 3073.40\nSELL@price: 3009.93\nBUY @price: 3034.88` \n```", "```py\n`$ ./stop-loss-approaches.py manual --plot --strat trail=20\nBUY @price: 3073.40\nSELL@price: 3070.72\nBUY @price: 3034.88\nSELL@price: 3076.54\nBUY @price: 3349.72\nSELL@price: 3339.65\nBUY @price: 3364.26\nSELL@price: 3393.96\nBUY @price: 3684.38\nSELL@price: 3708.25\nBUY @price: 3884.57\nSELL@price: 3867.00\nBUY @price: 3664.59\nSELL@price: 3650.75\nBUY @price: 3635.17\nSELL@price: 3661.55\nBUY @price: 4100.49\nSELL@price: 4120.66` \n```", "```py\n`class ManualStopOrStopTrailCheat(BaseStrategy):\n    params = dict(\n        stop_loss=0.02,  # price is 2% less than the entry point\n        trail=False,\n    )\n\n    def __init__(self):\n        super().__init__()\n        self.broker.set_coc(True)\n\n    def notify_order(self, order):\n        if not order.status == order.Completed:\n            return  # discard any other notification\n\n        if not self.position:  # we left the market\n            print('SELL@price: {:.2f}'.format(order.executed.price))\n            return\n\n        # We have entered the market\n        print('BUY @price: {:.2f}'.format(order.executed.price))\n\n    def next(self):\n        if not self.position and self.crossup > 0:\n            # not in the market and signal triggered\n            self.buy()\n\n            if not self.p.trail:\n                stop_price = self.data.close[0] * (1.0 - self.p.stop_loss)\n                self.sell(exectype=bt.Order.Stop, price=stop_price)\n            else:\n                self.sell(exectype=bt.Order.StopTrail,\n                          trailamount=self.p.trail)` \n```", "```py\n`$ ./stop-loss-approaches.py manualcheat --plot --strat trail=20\nBUY @price: 3076.23\nSELL@price: 3070.72\nBUY @price: 3036.30\nSELL@price: 3076.54\nBUY @price: 3349.46\nSELL@price: 3339.65\nBUY @price: 3362.83\nSELL@price: 3393.96\nSELL@price: 3685.48\nSELL@price: 3665.48\nSELL@price: 3888.46\nSELL@price: 3868.46\nBUY @price: 3662.92\nSELL@price: 3650.75\nBUY @price: 3631.50\nSELL@price: 3661.55\nBUY @price: 4094.33\nSELL@price: 4120.66` \n```", "```py\n`class AutoStopOrStopTrail(BaseStrategy):\n    params = dict(\n        stop_loss=0.02,  # price is 2% less than the entry point\n        trail=False,\n        buy_limit=False,\n    )\n\n    buy_order = None  # default value for a potential buy_order\n\n    def notify_order(self, order):\n        if order.status == order.Cancelled:\n            print('CANCEL@price: {:.2f} {}'.format(\n                order.executed.price, 'buy' if order.isbuy() else 'sell'))\n            return\n\n        if not order.status == order.Completed:\n            return  # discard any other notification\n\n        if not self.position:  # we left the market\n            print('SELL@price: {:.2f}'.format(order.executed.price))\n            return\n\n        # We have entered the market\n        print('BUY @price: {:.2f}'.format(order.executed.price))\n\n    def next(self):\n        if not self.position and self.crossup > 0:\n            if self.buy_order:  # something was pending\n                self.cancel(self.buy_order)\n\n            # not in the market and signal triggered\n            if not self.p.buy_limit:\n                self.buy_order = self.buy(transmit=False)\n            else:\n                price = self.data.close[0] * (1.0 - self.p.buy_limit)\n\n                # transmit = False ... await child order before transmission\n                self.buy_order = self.buy(price=price, exectype=bt.Order.Limit,\n                                          transmit=False)\n\n            # Setting parent=buy_order ... sends both together\n            if not self.p.trail:\n                stop_price = self.data.close[0] * (1.0 - self.p.stop_loss)\n                self.sell(exectype=bt.Order.Stop, price=stop_price,\n                          parent=self.buy_order)\n            else:\n                self.sell(exectype=bt.Order.StopTrail,\n                          trailamount=self.p.trail,\n                          parent=self.buy_order)` \n```", "```py\n`$ ./stop-loss-approaches.py auto --plot --strat trail=30,buy_limit=0.005\nBUY @price: 3060.85\nSELL@price: 3050.54\nCANCEL@price: 0.00 buy\nCANCEL@price: 0.00 sell\nBUY @price: 3332.71\nSELL@price: 3329.65\nCANCEL@price: 0.00 buy\nCANCEL@price: 0.00 sell\nBUY @price: 3667.05\nSELL@price: 3698.25\nBUY @price: 3869.02\nSELL@price: 3858.46\nBUY @price: 3644.61\nSELL@price: 3624.02\nCANCEL@price: 0.00 buy\nCANCEL@price: 0.00 sell\nBUY @price: 4073.86` \n```", "```py\n`$ ./stop-loss-approaches.py --help\nusage: stop-loss-approaches.py [-h] [--data0 DATA0] [--fromdate FROMDATE]\n                               [--todate TODATE] [--cerebro kwargs]\n                               [--broker kwargs] [--sizer kwargs]\n                               [--strat kwargs] [--plot [kwargs]]\n                               {manual,manualcheat,auto}\n\nStop-Loss Approaches\n\npositional arguments:\n  {manual,manualcheat,auto}\n                        Stop approach to use\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --data0 DATA0         Data to read in (default:\n                        ../../datas/2005-2006-day-001.txt)\n  --fromdate FROMDATE   Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: )\n  --todate TODATE       Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: )\n  --cerebro kwargs      kwargs in key=value format (default: )\n  --broker kwargs       kwargs in key=value format (default: )\n  --sizer kwargs        kwargs in key=value format (default: )\n  --strat kwargs        kwargs in key=value format (default: )\n  --plot [kwargs]       kwargs in key=value format (default: )` \n```", "```py\n`from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport argparse\nimport datetime\n\nimport backtrader as bt\n\nclass BaseStrategy(bt.Strategy):\n    params = dict(\n        fast_ma=10,\n        slow_ma=20,\n    )\n\n    def __init__(self):\n        # omitting a data implies self.datas[0] (aka self.data and self.data0)\n        fast_ma = bt.ind.EMA(period=self.p.fast_ma)\n        slow_ma = bt.ind.EMA(period=self.p.slow_ma)\n        # our entry point\n        self.crossup = bt.ind.CrossUp(fast_ma, slow_ma)\n\nclass ManualStopOrStopTrail(BaseStrategy):\n    params = dict(\n        stop_loss=0.02,  # price is 2% less than the entry point\n        trail=False,\n    )\n\n    def notify_order(self, order):\n        if not order.status == order.Completed:\n            return  # discard any other notification\n\n        if not self.position:  # we left the market\n            print('SELL@price: {:.2f}'.format(order.executed.price))\n            return\n\n        # We have entered the market\n        print('BUY @price: {:.2f}'.format(order.executed.price))\n\n        if not self.p.trail:\n            stop_price = order.executed.price * (1.0 - self.p.stop_loss)\n            self.sell(exectype=bt.Order.Stop, price=stop_price)\n        else:\n            self.sell(exectype=bt.Order.StopTrail, trailamount=self.p.trail)\n\n    def next(self):\n        if not self.position and self.crossup > 0:\n            # not in the market and signal triggered\n            self.buy()\n\nclass ManualStopOrStopTrailCheat(BaseStrategy):\n    params = dict(\n        stop_loss=0.02,  # price is 2% less than the entry point\n        trail=False,\n    )\n\n    def __init__(self):\n        super().__init__()\n        self.broker.set_coc(True)\n\n    def notify_order(self, order):\n        if not order.status == order.Completed:\n            return  # discard any other notification\n\n        if not self.position:  # we left the market\n            print('SELL@price: {:.2f}'.format(order.executed.price))\n            return\n\n        # We have entered the market\n        print('BUY @price: {:.2f}'.format(order.executed.price))\n\n    def next(self):\n        if not self.position and self.crossup > 0:\n            # not in the market and signal triggered\n            self.buy()\n\n            if not self.p.trail:\n                stop_price = self.data.close[0] * (1.0 - self.p.stop_loss)\n                self.sell(exectype=bt.Order.Stop, price=stop_price)\n            else:\n                self.sell(exectype=bt.Order.StopTrail,\n                          trailamount=self.p.trail)\n\nclass AutoStopOrStopTrail(BaseStrategy):\n    params = dict(\n        stop_loss=0.02,  # price is 2% less than the entry point\n        trail=False,\n        buy_limit=False,\n    )\n\n    buy_order = None  # default value for a potential buy_order\n\n    def notify_order(self, order):\n        if order.status == order.Cancelled:\n            print('CANCEL@price: {:.2f} {}'.format(\n                order.executed.price, 'buy' if order.isbuy() else 'sell'))\n            return\n\n        if not order.status == order.Completed:\n            return  # discard any other notification\n\n        if not self.position:  # we left the market\n            print('SELL@price: {:.2f}'.format(order.executed.price))\n            return\n\n        # We have entered the market\n        print('BUY @price: {:.2f}'.format(order.executed.price))\n\n    def next(self):\n        if not self.position and self.crossup > 0:\n            if self.buy_order:  # something was pending\n                self.cancel(self.buy_order)\n\n            # not in the market and signal triggered\n            if not self.p.buy_limit:\n                self.buy_order = self.buy(transmit=False)\n            else:\n                price = self.data.close[0] * (1.0 - self.p.buy_limit)\n\n                # transmit = False ... await child order before transmission\n                self.buy_order = self.buy(price=price, exectype=bt.Order.Limit,\n                                          transmit=False)\n\n            # Setting parent=buy_order ... sends both together\n            if not self.p.trail:\n                stop_price = self.data.close[0] * (1.0 - self.p.stop_loss)\n                self.sell(exectype=bt.Order.Stop, price=stop_price,\n                          parent=self.buy_order)\n            else:\n                self.sell(exectype=bt.Order.StopTrail,\n                          trailamount=self.p.trail,\n                          parent=self.buy_order)\n\nAPPROACHES = dict(\n    manual=ManualStopOrStopTrail,\n    manualcheat=ManualStopOrStopTrailCheat,\n    auto=AutoStopOrStopTrail,\n)\n\ndef runstrat(args=None):\n    args = parse_args(args)\n\n    cerebro = bt.Cerebro()\n\n    # Data feed kwargs\n    kwargs = dict()\n\n    # Parse from/to-date\n    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'\n    for a, d in ((getattr(args, x), x) for x in ['fromdate', 'todate']):\n        if a:\n            strpfmt = dtfmt + tmfmt * ('T' in a)\n            kwargs[d] = datetime.datetime.strptime(a, strpfmt)\n\n    data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs)\n    cerebro.adddata(data0)\n\n    # Broker\n    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' + args.broker + ')'))\n\n    # Sizer\n    cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' + args.sizer + ')'))\n\n    # Strategy\n    StClass = APPROACHES[args.approach]\n    cerebro.addstrategy(StClass, **eval('dict(' + args.strat + ')'))\n\n    # Execute\n    cerebro.run(**eval('dict(' + args.cerebro + ')'))\n\n    if args.plot:  # Plot if requested to\n        cerebro.plot(**eval('dict(' + args.plot + ')'))\n\ndef parse_args(pargs=None):\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n        description=(\n            'Stop-Loss Approaches'\n        )\n    )\n\n    parser.add_argument('--data0', default='../../datas/2005-2006-day-001.txt',\n                        required=False, help='Data to read in')\n\n    # Strategy to choose\n    parser.add_argument('approach', choices=APPROACHES.keys(),\n                        help='Stop approach to use')\n\n    # Defaults for dates\n    parser.add_argument('--fromdate', required=False, default='',\n                        help='Date[time] in YYYY-MM-DD[THH:MM:SS] format')\n\n    parser.add_argument('--todate', required=False, default='',\n                        help='Date[time] in YYYY-MM-DD[THH:MM:SS] format')\n\n    parser.add_argument('--cerebro', required=False, default='',\n                        metavar='kwargs', help='kwargs in key=value format')\n\n    parser.add_argument('--broker', required=False, default='',\n                        metavar='kwargs', help='kwargs in key=value format')\n\n    parser.add_argument('--sizer', required=False, default='',\n                        metavar='kwargs', help='kwargs in key=value format')\n\n    parser.add_argument('--strat', required=False, default='',\n                        metavar='kwargs', help='kwargs in key=value format')\n\n    parser.add_argument('--plot', required=False, default='',\n                        nargs='?', const='{}',\n                        metavar='kwargs', help='kwargs in key=value format')\n\n    return parser.parse_args(pargs)\n\nif __name__ == '__main__':\n    runstrat()` \n```"]