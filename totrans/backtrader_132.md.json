["```py\n`class MyIndicator(bt.Indicator):\n    lines = ('myline',)\n    params = (\n        ('period', 50),\n    )` \n```", "```py\n`def __init__(self):\n    print('my period is:', self.p.period)` \n```", "```py\n`def next(self):\n    print('mylines[0]:', self.lines.myline[0])` \n```", "```py\n`class MyIndicator(bt.Indicator):\n    packages = ('pandas',)\n    lines = ('myline',)\n    params = (\n        ('period', 50),\n    )` \n```", "```py\n`def next(self):\n    print('mylines[0]:', pandas.SomeFunction(self.lines.myline[0]))` \n```", "```py\n`class MyIndicator(bt.Indicator):\n    packages = ('pandas', ('statsmodel', 'sm'),)\n    lines = ('myline',)\n    params = (\n        ('period', 50),\n    )\n\n    def next(self):\n        print('mylines[0]:', sm.XX(pandas.SomeFunction(self.lines.myline[0])))` \n```", "```py\n`from pandas import SomeFunction` \n```", "```py\n`from pandas import SomeFunction as SomeFunc` \n```", "```py\n`class MyIndicator(bt.Indicator):\n    frompackages = (('pandas', 'SomeFunction'),)\n    lines = ('myline',)\n    params = (\n        ('period', 50),\n    )\n\n    def next(self):\n        print('mylines[0]:', SomeFunction(self.lines.myline[0]))` \n```", "```py\n`class MyIndicator(bt.Indicator):\n    frompackages = (('pandas', ['SomeFunction', 'SomeFunction2']),)\n    lines = ('myline',)\n    params = (\n        ('period', 50),\n    )\n\n    def next(self):\n        print('mylines[0]:', SomeFunction2(SomeFunction(self.lines.myline[0])))` \n```", "```py\n`class MyIndicator(bt.Indicator):\n    frompackages = (('pandas', [('SomeFunction', 'SFunc'), 'SomeFunction2']),)\n    lines = ('myline',)\n    params = (\n        ('period', 50),\n    )\n\n    def next(self):\n        print('mylines[0]:', SomeFunction2(SFunc(self.lines.myline[0])))` \n```", "```py\n`class MyIndicator(bt.Indicator):\n    frompackages = (\n        ('pandas', [('SomeFunction', 'SFunc'), 'SomeFunction2']),\n        ('statsmodel', 'XX'),\n    )\n    lines = ('myline',)\n    params = (\n        ('period', 50),\n    )\n\n    def next(self):\n        print('mylines[0]:', XX(SomeFunction2(SFunc(self.lines.myline[0]))))` \n```", "```py\n`class NumPySupport(object):\n    packages = ('numpy',)\n\nclass MyIndicator(bt.Indicator, NumPySupport):\n    packages = ('pandas',)` \n```", "```py\n`class KalmanMovingAverage(bt.indicators.MovingAverageBase):\n    packages = ('pykalman',)\n    frompackages = (('pykalman', [('KalmanFilter', 'KF')]),)\n    lines = ('kma',)\n    alias = ('KMA',)\n    params = (\n        ('initial_state_covariance', 1.0),\n        ('observation_covariance', 1.0),\n        ('transition_covariance', 0.05),\n    )\n\n    plotlines = dict(cov=dict(_plotskip=True))\n\n    def __init__(self):\n        self.addminperiod(self.p.period)  # when to deliver values\n        self._dlast = self.data(-1)  # get previous day value\n\n    def nextstart(self):\n        self._k1 = self._dlast[0]\n        self._c1 = self.p.initial_state_covariance\n\n        self._kf = pykalman.KalmanFilter(\n            transition_matrices=[1],\n            observation_matrices=[1],\n            observation_covariance=self.p.observation_covariance,\n            transition_covariance=self.p.transition_covariance,\n            initial_state_mean=self._k1,\n            initial_state_covariance=self._c1,\n        )\n\n        self.next()\n\n    def next(self):\n        k1, self._c1 = self._kf.filter_update(self._k1, self._c1, self.data[0])\n        self.lines.kma[0] = self._k1 = k1` \n```", "```py\n`class NumPy(object):\n    packages = (('numpy', 'np'),)\n\nclass KalmanFilterInd(bt.Indicator, NumPy):\n    _mindatas = 2  # needs at least 2 data feeds\n\n    packages = ('pandas',)\n    lines = ('et', 'sqrt_qt')\n\n    params = dict(\n        delta=1e-4,\n        vt=1e-3,\n    )\n\n    def __init__(self):\n        self.wt = self.p.delta / (1 - self.p.delta) * np.eye(2)\n        self.theta = np.zeros(2)\n        self.P = np.zeros((2, 2))\n        self.R = None\n\n        self.d1_prev = self.data1(-1)  # data1 yesterday's price\n\n    def next(self):\n        F = np.asarray([self.data0[0], 1.0]).reshape((1, 2))\n        y = self.d1_prev[0]\n\n        if self.R is not None:  # self.R starts as None, self.C set below\n            self.R = self.C + self.wt\n        else:\n            self.R = np.zeros((2, 2))\n\n        yhat = F.dot(self.theta)\n        et = y - yhat\n\n        # Q_t is the variance of the prediction of observations and hence\n        # \\sqrt{Q_t} is the standard deviation of the predictions\n        Qt = F.dot(self.R).dot(F.T) + self.p.vt\n        sqrt_Qt = np.sqrt(Qt)\n\n        # The posterior value of the states \\theta_t is distributed as a\n        # multivariate Gaussian with mean m_t and variance-covariance C_t\n        At = self.R.dot(F.T) / Qt\n        self.theta = self.theta + At.flatten() * et\n        self.C = self.R - At * F.dot(self.R)\n\n        # Fill the lines\n        self.lines.et[0] = et\n        self.lines.sqrt_qt[0] = sqrt_Qt` \n```", "```py\n`$ ./kalman-things.py --plot` \n```", "```py\n`$ ./kalman-things.py --help\nusage: kalman-things.py [-h] [--data0 DATA0] [--data1 DATA1]\n                        [--fromdate FROMDATE] [--todate TODATE]\n                        [--cerebro kwargs] [--broker kwargs] [--sizer kwargs]\n                        [--strat kwargs] [--plot [kwargs]]\n\nPackages and Kalman\n\noptional arguments:\n  -h, --help           show this help message and exit\n  --data0 DATA0        Data to read in (default:\n                       ../../datas/nvda-1999-2014.txt)\n  --data1 DATA1        Data to read in (default:\n                       ../../datas/orcl-1995-2014.txt)\n  --fromdate FROMDATE  Date[time] in YYYY-MM-DD[THH:MM:SS] format (default:\n                       2006-01-01)\n  --todate TODATE      Date[time] in YYYY-MM-DD[THH:MM:SS] format (default:\n                       2007-01-01)\n  --cerebro kwargs     kwargs in key=value format (default: runonce=False)\n  --broker kwargs      kwargs in key=value format (default: )\n  --sizer kwargs       kwargs in key=value format (default: )\n  --strat kwargs       kwargs in key=value format (default: )\n  --plot [kwargs]      kwargs in key=value format (default: )` \n```", "```py\n`from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport argparse\nimport datetime\n\nimport backtrader as bt\n\nclass KalmanMovingAverage(bt.indicators.MovingAverageBase):\n    packages = ('pykalman',)\n    frompackages = (('pykalman', [('KalmanFilter', 'KF')]),)\n    lines = ('kma',)\n    alias = ('KMA',)\n    params = (\n        ('initial_state_covariance', 1.0),\n        ('observation_covariance', 1.0),\n        ('transition_covariance', 0.05),\n    )\n\n    def __init__(self):\n        self.addminperiod(self.p.period)  # when to deliver values\n        self._dlast = self.data(-1)  # get previous day value\n\n    def nextstart(self):\n        self._k1 = self._dlast[0]\n        self._c1 = self.p.initial_state_covariance\n\n        self._kf = pykalman.KalmanFilter(\n            transition_matrices=[1],\n            observation_matrices=[1],\n            observation_covariance=self.p.observation_covariance,\n            transition_covariance=self.p.transition_covariance,\n            initial_state_mean=self._k1,\n            initial_state_covariance=self._c1,\n        )\n\n        self.next()\n\n    def next(self):\n        k1, self._c1 = self._kf.filter_update(self._k1, self._c1, self.data[0])\n        self.lines.kma[0] = self._k1 = k1\n\nclass NumPy(object):\n    packages = (('numpy', 'np'),)\n\nclass KalmanFilterInd(bt.Indicator, NumPy):\n    _mindatas = 2  # needs at least 2 data feeds\n\n    packages = ('pandas',)\n    lines = ('et', 'sqrt_qt')\n\n    params = dict(\n        delta=1e-4,\n        vt=1e-3,\n    )\n\n    def __init__(self):\n        self.wt = self.p.delta / (1 - self.p.delta) * np.eye(2)\n        self.theta = np.zeros(2)\n        self.R = None\n\n        self.d1_prev = self.data1(-1)  # data1 yesterday's price\n\n    def next(self):\n        F = np.asarray([self.data0[0], 1.0]).reshape((1, 2))\n        y = self.d1_prev[0]\n\n        if self.R is not None:  # self.R starts as None, self.C set below\n            self.R = self.C + self.wt\n        else:\n            self.R = np.zeros((2, 2))\n\n        yhat = F.dot(self.theta)\n        et = y - yhat\n\n        # Q_t is the variance of the prediction of observations and hence\n        # \\sqrt{Q_t} is the standard deviation of the predictions\n        Qt = F.dot(self.R).dot(F.T) + self.p.vt\n        sqrt_Qt = np.sqrt(Qt)\n\n        # The posterior value of the states \\theta_t is distributed as a\n        # multivariate Gaussian with mean m_t and variance-covariance C_t\n        At = self.R.dot(F.T) / Qt\n        self.theta = self.theta + At.flatten() * et\n        self.C = self.R - At * F.dot(self.R)\n\n        # Fill the lines\n        self.lines.et[0] = et\n        self.lines.sqrt_qt[0] = sqrt_Qt\n\nclass KalmanSignals(bt.Indicator):\n    _mindatas = 2  # needs at least 2 data feeds\n\n    lines = ('long', 'short',)\n\n    def __init__(self):\n        kf = KalmanFilterInd()\n        et, sqrt_qt = kf.lines.et, kf.lines.sqrt_qt\n\n        self.lines.long = et < -1.0 * sqrt_qt\n        # longexit is et > -1.0 * sqrt_qt ... the opposite of long\n        self.lines.short = et > sqrt_qt\n        # shortexit is et < sqrt_qt ... the opposite of short\n\nclass St(bt.Strategy):\n    params = dict(\n        ksigs=False,  # attempt trading\n        period=30,\n    )\n\n    def __init__(self):\n        if self.p.ksigs:\n            self.ksig = KalmanSignals()\n            KalmanFilter()\n\n        KalmanMovingAverage(period=self.p.period)\n        bt.ind.SMA(period=self.p.period)\n        if True:\n            kf = KalmanFilterInd()\n            kf.plotlines.sqrt_qt._plotskip = True\n\n    def next(self):\n        if not self.p.ksigs:\n            return\n\n        size = self.position.size\n        if not size:\n            if self.ksig.long:\n                self.buy()\n            elif self.ksig.short:\n                self.sell()\n\n        elif size > 0:\n            if not self.ksig.long:\n                self.close()\n        elif not self.ksig.short:  # implicit size < 0\n            self.close()\n\ndef runstrat(args=None):\n    args = parse_args(args)\n\n    cerebro = bt.Cerebro()\n\n    # Data feed kwargs\n    kwargs = dict()\n\n    # Parse from/to-date\n    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'\n    for a, d in ((getattr(args, x), x) for x in ['fromdate', 'todate']):\n        if a:\n            strpfmt = dtfmt + tmfmt * ('T' in a)\n            kwargs[d] = datetime.datetime.strptime(a, strpfmt)\n\n    # Data feed\n    data0 = bt.feeds.YahooFinanceCSVData(dataname=args.data0, **kwargs)\n    cerebro.adddata(data0)\n\n    data1 = bt.feeds.YahooFinanceCSVData(dataname=args.data1, **kwargs)\n    data1.plotmaster = data0\n    cerebro.adddata(data1)\n\n    # Broker\n    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' + args.broker + ')'))\n\n    # Sizer\n    cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' + args.sizer + ')'))\n\n    # Strategy\n    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))\n\n    # Execute\n    cerebro.run(**eval('dict(' + args.cerebro + ')'))\n\n    if args.plot:  # Plot if requested to\n        cerebro.plot(**eval('dict(' + args.plot + ')'))\n\ndef parse_args(pargs=None):\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n        description=(\n            'Packages and Kalman'\n        )\n    )\n\n    parser.add_argument('--data0', default='../../datas/nvda-1999-2014.txt',\n                        required=False, help='Data to read in')\n\n    parser.add_argument('--data1', default='../../datas/orcl-1995-2014.txt',\n                        required=False, help='Data to read in')\n\n    # Defaults for dates\n    parser.add_argument('--fromdate', required=False, default='2006-01-01',\n                        help='Date[time] in YYYY-MM-DD[THH:MM:SS] format')\n\n    parser.add_argument('--todate', required=False, default='2007-01-01',\n                        help='Date[time] in YYYY-MM-DD[THH:MM:SS] format')\n\n    parser.add_argument('--cerebro', required=False, default='runonce=False',\n                        metavar='kwargs', help='kwargs in key=value format')\n\n    parser.add_argument('--broker', required=False, default='',\n                        metavar='kwargs', help='kwargs in key=value format')\n\n    parser.add_argument('--sizer', required=False, default='',\n                        metavar='kwargs', help='kwargs in key=value format')\n\n    parser.add_argument('--strat', required=False, default='',\n                        metavar='kwargs', help='kwargs in key=value format')\n\n    parser.add_argument('--plot', required=False, default='',\n                        nargs='?', const='{}',\n                        metavar='kwargs', help='kwargs in key=value format')\n\n    return parser.parse_args(pargs)\n\nif __name__ == '__main__':\n    runstrat()` \n```"]