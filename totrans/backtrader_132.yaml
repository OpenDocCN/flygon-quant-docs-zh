- en: Kalman et al.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://www.backtrader.com/blog/posts/2017-02-14-kalman-et-al/kalman-et-al/](https://www.backtrader.com/blog/posts/2017-02-14-kalman-et-al/kalman-et-al/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The support for the directives below starts with commit
  prefs: []
  type: TYPE_NORMAL
- en: 1146c83d9f9832630e97daab3ec7359705dc2c77 in the development branch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Release `1.9.30.x` will be the 1^(st) to include it.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the original goals of *backtrader* was to be pure python, i.e.: to only
    use packages available in the standard distribution. A single exception was made
    with `matplotlib` to have plotting without reinventing the wheel. Although is
    imported at the latest possible moment to avoid disrupting standard operations
    which may not require plotting at all (and avoiding errors if not installed and
    not wished)'
  prefs: []
  type: TYPE_NORMAL
- en: A 2^(nd) exception was partially made with `pytz` when adding support for timezones
    with the advent of live data feeds which may reside outside of the local timezone.
    Again the *import* action happens in the background and only if `pytz` is available
    (the user may choose to pass `pytz` instances)
  prefs: []
  type: TYPE_NORMAL
- en: But the moment has come to make a full exception, because *backtraders* are
    using well known packages like `numpy`, `pandas`, `statsmodel` and some more modest
    ones like `pykalman`. Or else inclusion in the platform of things which use those
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples from the community:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Porting a pandas dataframe dependent indicator](https://community.backtrader.com/topic/11/porting-a-pandas-dataframe-dependent-indicator)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[linear regression and std #211](https://community.backtrader.com/topic/5/linear-regression-and-std-211)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Machine learning + backtrader](https://community.backtrader.com/topic/102/machine-learning-backtrader)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This wish was added to the quick roadmap sketched here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[v1.x -Quick Roadmap](https://community.backtrader.com/topic/195/v1-x-quick-roadmap)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The declarative approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Key in keeping the original spirit of *backtrader* and at the same allowing
    the use of those packages is to not **force** pure python users to have to install
    those packages.
  prefs: []
  type: TYPE_NORMAL
- en: Although this may seem challenging and prone to multiple conditional statements
    here and there, together with exception handling, the approach both internally
    in the platform and externally for users is to **rely on the same principles already
    used to develop other concepts**, like for example **parameters** (named *params*)
    for most objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s recall how one defines an `Indicator` accepting *params* and defining
    *lines*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With the parameter `period` later being addressable as `self.params.period`
    or `self.p.period` as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'and the current value in the line as `self.lines.myline` or `self.l.myline`
    as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This not being particularly useful, just showing the **declarative** approach
    of the **params** background machinery which also features proper support for
    inheritance (including *multiple inheritance*)
  prefs: []
  type: TYPE_NORMAL
- en: Introducing `packages`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the same declarative technique (some would call it *metaprogramming*)
    the support for foreign *packages* is available as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Blistering barnacles!!! It seems just another declaration. The first question
    for the implementer of the indicator would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Do I have to manually import ``pandas``?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And the answer is a straightforward: **No**. The background machinery will
    import `pandas` and make it available in the module in which `MyIndicator` is
    defined. One could now do the following in `next`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `packages` directive can be used also to:'
  prefs: []
  type: TYPE_NORMAL
- en: Import multiple packages in one single declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign the import to an alias ala `import pandas as pd`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s say that statsmodel is also wished as `sm` to complete `pandas.SomeFunction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`statsmodel` has been imported as `sm` and is available. It simply takes passing
    an iterable (a `tuple` is the *backtrader* convention) with the name of the package
    and the wished alias.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding `frompackages`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python is well known for the constant lookup for things which is one of the
    reasons for the language to be fantastic with regards to dynamism, introspection
    facilities and metaprogramming. At the same time is also one of the causes for
    not being able to deliver the same performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the usual speed ups is to remove lookup into modules by directly importing
    symbols from the modules, to have local lookups. With our `SomeFunction` from
    `pandas` this would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'or with an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*backtrader* offers support for both with the `frompackages` directive. Let’s
    rework `MyIndicator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this starts adding more parenthesis. For example if two (2) things
    are going to be imported from `pandas`, it would seem like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Where for the sake of clarity `SomeFunction` and `SomeFunction2` have been put
    in in a `list` instead of a `tuple`, to have square brackets, `[]` and be able
    to read it it a bit better.
  prefs: []
  type: TYPE_NORMAL
- en: 'One can also alias `SomeFunction` to for example `SFunc`. The full example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And importing from different packages is possible at the expense of more parenthesis.
    Of course line breaks and indentation do help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Using inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both `packages` and `frompackages` support (multiple) inheritance. There could
    for example be a base class which adds `numpy` support to all subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`MyIndicator` will require from the background machinery the import of both
    `numpy` and `pandas` and will be able to use them.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Kalman and friends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: both indicators below would need peer reviewing to confirm the implementations.
    Use with care.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample implementing a `KalmanMovingAverage` can be found below. This is modeled
    after a post here: [Quantopian Lecture Series: Kalman Filters](https://www.quantopian.com/posts/quantopian-lecture-series-kalman-filters)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And a `KalmanFilter` following a post here: [Kalman Filter-Based Pairs Trading
    Strategy In QSTrader](https://www.quantstart.com/articles/kalman-filter-based-pairs-trading-strategy-in-qstrader)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Which for the sake of it shows how `packages` also work with inheritance (`pandas`
    is not really needed)
  prefs: []
  type: TYPE_NORMAL
- en: 'An execution of the sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: produces this chart
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/10ae3c6245499d5f8732240a2bd6e431.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Sample Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
