["```py\n`breaking a *daily bar* in 2 parts to let people buy after having seen only the\nopening price. The 2nd part of the day (high, low, close) is evaluated in a\n2nd tick. This effectively achieves the *uses daily data (vs minute or tick\ndata) for intraday trading*.` \n```", "```py\n`$ ./pinkfish-challenge.py --no-replay` \n```", "```py\n`...\n0955,0478,0478,2006-11-22T00:00:00,27.51,28.56,27.29,28.49,16027900.00,0.00\nHigh 28.56 > Highest 28.56\nLAST 19 highs: array('d', [25.33, 25.6, 26.4, 26.7, 26.62, 26.6, 26.7, 26.7, 27.15, 27.25, 27.65, 27.5, 27.62,   27.5, 27.5, 27.33, 27.05, 27.04, 27.34])\n-- BUY on date: 2006-11-22\n-- BUY Completed on: 2006-11-22\n-- BUY Price: 28.49\n0956,0478,0478,2006-11-22T23:59:59.999989,27.51,28.56,27.29,28.49,32055800.00,0.00\n...` \n```", "```py\n`$ ./pinkfish-challenge.py --no-replay --market` \n```", "```py\n`...\n0955,0478,0478,2006-11-22T00:00:00,27.51,28.56,27.29,28.49,16027900.00,0.00\nHigh 28.56 > Highest 28.56\nLAST 19 highs: array('d', [25.33, 25.6, 26.4, 26.7, 26.62, 26.6, 26.7, 26.7, 27.15, 27.25, 27.65, 27.5, 27.62, 27.5, 27.5, 27.33, 27.05, 27.04, 27.34])\n-- BUY on date: 2006-11-22\n-- BUY Completed on: 2006-11-22\n-- BUY Price: 27.51\n0956,0478,0478,2006-11-22T23:59:59.999989,27.51,28.56,27.29,28.49,32055800.00,0.00\n...` \n```", "```py\n `# Make a copy of current data for ohlbar\n        ohlbar = [data.lines[i][0] for i in range(data.size())]\n        closebar = ohlbar[:]  # Make a copy for the close\n\n        # replace close price with o-h-l average\n        ohlprice = ohlbar[data.Open] + ohlbar[data.High] + ohlbar[data.Low]\n        ohlbar[data.Close] = ohlprice / 3.0\n\n        vol = ohlbar[data.Volume]  # adjust volume\n        ohlbar[data.Volume] = vohl = int(vol * (1.0 - self.p.closevol))\n\n        oi = ohlbar[data.OpenInterest]  # adjust open interst\n        ohlbar[data.OpenInterest] = 0\n\n        # Adjust times\n        dt = datetime.datetime.combine(datadt, data.p.sessionstart)\n        ohlbar[data.DateTime] = data.date2num(dt)\n\n        # Adjust closebar to generate a single tick -> close price\n        closebar[data.Open] = cprice = closebar[data.Close]\n        closebar[data.High] = cprice\n        closebar[data.Low] = cprice\n        closebar[data.Volume] = vol - vohl\n        ohlbar[data.OpenInterest] = oi\n\n        # Adjust times\n        dt = datetime.datetime.combine(datadt, data.p.sessionend)\n        closebar[data.DateTime] = data.date2num(dt)\n\n        # Update stream\n        data.backwards(force=True)  # remove the copied bar from stream\n        data._add2stack(ohlbar)  # add ohlbar to stack\n        # Add 2nd part to stash to delay processing to next round\n        data._add2stack(closebar, stash=True)\n\n        return False  # the length of the stream was not changed` \n```", "```py\n`$ ./pinkfish-challenge.py --plot` \n```", "```py\n`...\n0955,0478,0478,2006-11-22T00:00:00,27.51,28.56,27.29,27.79,16027900.00,0.00\nHigh 28.56 > Highest 28.56\nLAST 19 highs: array('d', [25.33, 25.6, 26.4, 26.7, 26.62, 26.6, 26.7, 26.7, 27.15, 27.25, 27.65, 27.5, 27.62, 27.5, 27.5, 27.33, 27.05, 27.04, 27.34])\n-- BUY on date: 2006-11-22\n-- BUY Completed on: 2006-11-22\n-- BUY Price: 28.49\n0956,0478,0478,2006-11-22T23:59:59.999989,27.51,28.56,27.29,28.49,32055800.00,0.00\n...` \n```", "```py\n`$ ./pinkfish-challenge.py --market` \n```", "```py\n`...\n0955,0478,0478,2006-11-22T00:00:00,27.51,28.56,27.29,27.79,16027900.00,0.00\nHigh 28.56 > Highest 28.56\nLAST 19 highs: array('d', [25.33, 25.6, 26.4, 26.7, 26.62, 26.6, 26.7, 26.7, 27.15, 27.25, 27.65, 27.5, 27.62, 27.5, 27.5, 27.33, 27.05, 27.04, 27.34])\n-- BUY on date: 2006-11-22\n-- BUY Completed on: 2006-11-22\n-- BUY Price: 28.49\n0956,0478,0478,2006-11-22T23:59:59.999989,27.51,28.56,27.29,28.49,32055800.00,0.00\n..` \n```", "```py\n`$ ./pinkfish-challenge.py --help\nusage: pinkfish-challenge.py [-h] [--data DATA] [--fromdate FROMDATE]\n                             [--todate TODATE] [--cash CASH]\n                             [--sellafter SELLAFTER] [--highperiod HIGHPERIOD]\n                             [--no-replay] [--market] [--oldbuysell]\n                             [--plot [kwargs]]\n\nSample for pinkfish challenge\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --data DATA           Data to be read in (default:\n                        ../../datas/yhoo-1996-2015.txt)\n  --fromdate FROMDATE   Starting date in YYYY-MM-DD format (default:\n                        2005-01-01)\n  --todate TODATE       Ending date in YYYY-MM-DD format (default: 2006-12-31)\n  --cash CASH           Cash to start with (default: 50000)\n  --sellafter SELLAFTER\n                        Sell after so many bars in market (default: 2)\n  --highperiod HIGHPERIOD\n                        Period to look for the highest (default: 20)\n  --no-replay           Use Replay + replay filter (default: False)\n  --market              Use Market exec instead of Close (default: False)\n  --oldbuysell          Old buysell plot behavior - ON THE PRICE (default:\n                        False)\n  --plot [kwargs], -p [kwargs]\n                        Plot the read data applying any kwargs passed For\n                        example (escape the quotes if needed): --plot\n                        style=\"candle\" (to plot candles) (default: None)` \n```", "```py\n`from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport argparse\nimport datetime\n\nimport backtrader as bt\nimport backtrader.indicators as btind\n\nclass DayStepsCloseFilter(bt.with_metaclass(bt.MetaParams, object)):\n    '''\n    Replays a bar in 2 steps:\n\n      - In the 1st step the \"Open-High-Low\" could be evaluated to decide if to\n        act on the close (the close is still there ... should not be evaluated)\n\n      - If a \"Close\" order has been executed\n\n        In this 1st fragment the \"Close\" is replaced through the \"open\" althoug\n        other alternatives would be possible like high - low average, or an\n        algorithm based on where the \"close\" ac\n\n      and\n\n      - Open-High-Low-Close\n    '''\n    params = (\n        ('cvol', 0.5),  # 0 -> 1 amount of volume to keep for close\n    )\n\n    def __init__(self, data):\n        self.pendingbar = None\n\n    def __call__(self, data):\n        # Make a copy of the new bar and remove it from stream\n        closebar = [data.lines[i][0] for i in range(data.size())]\n        datadt = data.datetime.date()  # keep the date\n\n        ohlbar = closebar[:]  # Make an open-high-low bar\n\n        # Adjust volume\n        ohlbar[data.Volume] = int(closebar[data.Volume] * (1.0 - self.p.cvol))\n\n        dt = datetime.datetime.combine(datadt, data.p.sessionstart)\n        ohlbar[data.DateTime] = data.date2num(dt)\n\n        dt = datetime.datetime.combine(datadt, data.p.sessionend)\n        closebar[data.DateTime] = data.date2num(dt)\n\n        # Update stream\n        data.backwards()  # remove the copied bar from stream\n        # Overwrite the new data bar with our pending data - except start point\n        if self.pendingbar is not None:\n            data._updatebar(self.pendingbar)\n\n        self.pendingbar = closebar  # update the pending bar to the new bar\n        data._add2stack(ohlbar)  # Add the openbar to the stack for processing\n\n        return False  # the length of the stream was not changed\n\n    def last(self, data):\n        '''Called when the data is no longer producing bars\n        Can be called multiple times. It has the chance to (for example)\n        produce extra bars'''\n        if self.pendingbar is not None:\n            data.backwards()  # remove delivered open bar\n            data._add2stack(self.pendingbar)  # add remaining\n            self.pendingbar = None  # No further action\n            return True  # something delivered\n\n        return False  # nothing delivered here\n\nclass DayStepsReplayFilter(bt.with_metaclass(bt.MetaParams, object)):\n    '''\n    Replays a bar in 2 steps:\n\n      - In the 1st step the \"Open-High-Low\" could be evaluated to decide if to\n        act on the close (the close is still there ... should not be evaluated)\n\n      - If a \"Close\" order has been executed\n\n        In this 1st fragment the \"Close\" is replaced through the \"open\" althoug\n        other alternatives would be possible like high - low average, or an\n        algorithm based on where the \"close\" ac\n\n      and\n\n      - Open-High-Low-Close\n    '''\n    params = (\n        ('closevol', 0.5),  # 0 -> 1 amount of volume to keep for close\n    )\n\n    # replaying = True\n\n    def __init__(self, data):\n        self.lastdt = None\n        pass\n\n    def __call__(self, data):\n        # Make a copy of the new bar and remove it from stream\n        datadt = data.datetime.date()  # keep the date\n\n        if self.lastdt == datadt:\n            return False  # skip bars that come again in the filter\n\n        self.lastdt = datadt  # keep ref to last seen bar\n\n        # Make a copy of current data for ohlbar\n        ohlbar = [data.lines[i][0] for i in range(data.size())]\n        closebar = ohlbar[:]  # Make a copy for the close\n\n        # replace close price with o-h-l average\n        ohlprice = ohlbar[data.Open] + ohlbar[data.High] + ohlbar[data.Low]\n        ohlbar[data.Close] = ohlprice / 3.0\n\n        vol = ohlbar[data.Volume]  # adjust volume\n        ohlbar[data.Volume] = vohl = int(vol * (1.0 - self.p.closevol))\n\n        oi = ohlbar[data.OpenInterest]  # adjust open interst\n        ohlbar[data.OpenInterest] = 0\n\n        # Adjust times\n        dt = datetime.datetime.combine(datadt, data.p.sessionstart)\n        ohlbar[data.DateTime] = data.date2num(dt)\n\n        # Adjust closebar to generate a single tick -> close price\n        closebar[data.Open] = cprice = closebar[data.Close]\n        closebar[data.High] = cprice\n        closebar[data.Low] = cprice\n        closebar[data.Volume] = vol - vohl\n        ohlbar[data.OpenInterest] = oi\n\n        # Adjust times\n        dt = datetime.datetime.combine(datadt, data.p.sessionend)\n        closebar[data.DateTime] = data.date2num(dt)\n\n        # Update stream\n        data.backwards(force=True)  # remove the copied bar from stream\n        data._add2stack(ohlbar)  # add ohlbar to stack\n        # Add 2nd part to stash to delay processing to next round\n        data._add2stack(closebar, stash=True)\n\n        return False  # the length of the stream was not changed\n\nclass St(bt.Strategy):\n    params = (\n        ('highperiod', 20),\n        ('sellafter', 2),\n        ('market', False),\n    )\n\n    def __init__(self):\n        pass\n\n    def start(self):\n        self.callcounter = 0\n        txtfields = list()\n        txtfields.append('Calls')\n        txtfields.append('Len Strat')\n        txtfields.append('Len Data')\n        txtfields.append('Datetime')\n        txtfields.append('Open')\n        txtfields.append('High')\n        txtfields.append('Low')\n        txtfields.append('Close')\n        txtfields.append('Volume')\n        txtfields.append('OpenInterest')\n        print(','.join(txtfields))\n\n        self.lcontrol = 0  # control if 1st or 2nd call\n        self.inmarket = 0\n\n        # Get the highest but delayed 1 ... to avoid \"today\"\n        self.highest = btind.Highest(self.data.high,\n                                     period=self.p.highperiod,\n                                     subplot=False)\n\n    def notify_order(self, order):\n        if order.isbuy() and order.status == order.Completed:\n            print('-- BUY Completed on:',\n                  self.data.num2date(order.executed.dt).strftime('%Y-%m-%d'))\n            print('-- BUY Price:', order.executed.price)\n\n    def next(self):\n        self.callcounter += 1\n\n        txtfields = list()\n        txtfields.append('%04d' % self.callcounter)\n        txtfields.append('%04d' % len(self))\n        txtfields.append('%04d' % len(self.data0))\n        txtfields.append(self.data.datetime.datetime(0).isoformat())\n        txtfields.append('%.2f' % self.data0.open[0])\n        txtfields.append('%.2f' % self.data0.high[0])\n        txtfields.append('%.2f' % self.data0.low[0])\n        txtfields.append('%.2f' % self.data0.close[0])\n        txtfields.append('%.2f' % self.data0.volume[0])\n        txtfields.append('%.2f' % self.data0.openinterest[0])\n        print(','.join(txtfields))\n\n        if not self.position:\n            if len(self.data) > self.lcontrol:\n                if self.data.high == self.highest:  # today is highest!!!\n                    print('High %.2f > Highest %.2f' %\n                          (self.data.high[0], self.highest[0]))\n                    print('LAST 19 highs:',\n                          self.data.high.get(size=19, ago=-1))\n                    print('-- BUY on date:',\n                          self.data.datetime.date().strftime('%Y-%m-%d'))\n                    ex = bt.Order.Market if self.p.market else bt.Order.Close\n                    self.buy(exectype=ex)\n                    self.inmarket = len(self)  # reset period in market\n\n        else:  # in the market\n            if (len(self) - self.inmarket) >= self.p.sellafter:\n                self.sell()\n\n        self.lcontrol = len(self.data)\n\ndef runstrat():\n    args = parse_args()\n\n    cerebro = bt.Cerebro()\n    cerebro.broker.set_cash(args.cash)\n    cerebro.broker.set_eosbar(True)\n\n    dkwargs = dict()\n    if args.fromdate:\n        fromdate = datetime.datetime.strptime(args.fromdate, '%Y-%m-%d')\n        dkwargs['fromdate'] = fromdate\n\n    if args.todate:\n        todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')\n        dkwargs['todate'] = todate\n\n    if args.no_replay:\n        data = bt.feeds.YahooFinanceCSVData(dataname=args.data,\n                                            timeframe=bt.TimeFrame.Days,\n                                            compression=1,\n                                            **dkwargs)\n        data.addfilter(DayStepsCloseFilter)\n        cerebro.adddata(data)\n    else:\n        data = bt.feeds.YahooFinanceCSVData(dataname=args.data,\n                                            timeframe=bt.TimeFrame.Minutes,\n                                            compression=1,\n                                            **dkwargs)\n        data.addfilter(DayStepsReplayFilter)\n        cerebro.replaydata(data, timeframe=bt.TimeFrame.Days, compression=1)\n\n    cerebro.addstrategy(St,\n                        sellafter=args.sellafter,\n                        highperiod=args.highperiod,\n                        market=args.market)\n\n    cerebro.run(runonce=False, preload=False, oldbuysell=args.oldbuysell)\n    if args.plot:\n        pkwargs = dict(style='bar')\n        if args.plot is not True:  # evals to True but is not True\n            npkwargs = eval('dict(' + args.plot + ')')  # args were passed\n            pkwargs.update(npkwargs)\n\n        cerebro.plot(**pkwargs)\n\ndef parse_args(pargs=None):\n\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n        description='Sample for pinkfish challenge')\n\n    parser.add_argument('--data', required=False,\n                        default='../../datas/yhoo-1996-2015.txt',\n                        help='Data to be read in')\n\n    parser.add_argument('--fromdate', required=False,\n                        default='2005-01-01',\n                        help='Starting date in YYYY-MM-DD format')\n\n    parser.add_argument('--todate', required=False,\n                        default='2006-12-31',\n                        help='Ending date in YYYY-MM-DD format')\n\n    parser.add_argument('--cash', required=False, action='store',\n                        type=float, default=50000,\n                        help=('Cash to start with'))\n\n    parser.add_argument('--sellafter', required=False, action='store',\n                        type=int, default=2,\n                        help=('Sell after so many bars in market'))\n\n    parser.add_argument('--highperiod', required=False, action='store',\n                        type=int, default=20,\n                        help=('Period to look for the highest'))\n\n    parser.add_argument('--no-replay', required=False, action='store_true',\n                        help=('Use Replay + replay filter'))\n\n    parser.add_argument('--market', required=False, action='store_true',\n                        help=('Use Market exec instead of Close'))\n\n    parser.add_argument('--oldbuysell', required=False, action='store_true',\n                        help=('Old buysell plot behavior - ON THE PRICE'))\n\n    # Plot options\n    parser.add_argument('--plot', '-p', nargs='?', required=False,\n                        metavar='kwargs', const=True,\n                        help=('Plot the read data applying any kwargs passed\\n'\n                              '\\n'\n                              'For example (escape the quotes if needed):\\n'\n                              '\\n'\n                              '  --plot style=\"candle\" (to plot candles)\\n'))\n\n    if pargs is not None:\n        return parser.parse_args(pargs)\n\n    return parser.parse_args()\n\nif __name__ == '__main__':\n    runstrat()` \n```"]