["```py\n `If no `pytz` is detected and no `tzinfo` compatible instance is\n  supplied to the *data feed*, the time delivered by the platform will be\n  `UTC`` \n```", "```py\n`$ ./ibtest.py --port 7497 --data0 TWTR --resample --timeframe Seconds --compression 5` \n```", "```py\n`Server Version: 76\nTWS Time at connection:20160620 22:37:37 CET\n--------------------------------------------------\nStrategy Created\n--------------------------------------------------\nTimezone from ContractDetails: EST5EDT\nDatetime, Open, High, Low, Close, Volume, OpenInterest, SMA\n***** STORE NOTIF: <error id=-1, errorCode=2104, errorMsg=Market data farm connection is OK:ibdemo>\n***** STORE NOTIF: <error id=-1, errorCode=2106, errorMsg=HMDS data farm connection is OK:demohmds>\n***** DATA NOTIF: CONNECTED\n0001, 2016-06-20T14:37:35.000000, 15.96, 15.97, 15.96, 15.96, 0.0, 0, nan\n***** DATA NOTIF: DELAYED\n0002, 2016-06-20T14:37:40.000000, 15.96, 15.97, 15.96, 15.96, 0.0, 0, nan\n0003, 2016-06-20T14:37:45.000000, 15.96, 15.97, 15.96, 15.97, 0.0, 0, nan\n0004, 2016-06-20T14:37:50.000000, 15.96, 15.98, 15.94, 15.94, 0.0, 0, nan\n0005, 2016-06-20T14:37:55.000000, 15.97, 15.97, 15.96, 15.97, 0.0, 0, 15.96\n...\n1441, 2016-06-20T16:37:35.000000, 16.03, 16.03, 16.02, 16.03, 0.0, 0, 16.026\n1442, 2016-06-20T16:37:40.000000, 16.11, 16.11, 16.11, 16.11, 2.0, 0, 16.044\n***** DATA NOTIF: LIVE\n1443, 2016-06-20T16:37:45.000000, 16.1, 16.11, 16.1, 16.11, 5.0, 0, 16.06\n1444, 2016-06-20T16:37:50.000000, 16.11, 16.11, 16.1, 16.1, 14.0, 0, 16.076\n...` \n```", "```py\n`$ ./ibtest.py --port 7497 --data0 TWTR --resample --timeframe Seconds --compression 5` \n```", "```py\n`...\n1440, 2016-06-20T18:16:20.000000, 16.05, 16.05, 16.04, 16.04, 0.0, 0, 16.048\n1441, 2016-06-20T18:16:25.000000, 16.05, 16.05, 16.05, 16.05, 0.0, 0, 16.05\n***** DATA NOTIF: LIVE\n1442, 2016-06-20T18:16:30.000000, 15.9, 15.9, 15.89, 15.9, 11.0, 0, 16.02\n***** STORE NOTIF: <error id=-1, errorCode=1100, errorMsg=Connectivity between IB and TWS has been lost.>\n***** STORE NOTIF: <error id=-1, errorCode=2105, errorMsg=HMDS data farm connection is broken:demohmds>\n***** STORE NOTIF: <error id=-1, errorCode=2103, errorMsg=Market data farm connection is broken:ibdemo>\n1443, 2016-06-20T18:16:35.000000, 15.9, 15.9, 15.89, 15.9, 28.0, 0, 15.988\n***** STORE NOTIF: <error id=-1, errorCode=1102, errorMsg=Connectivity between IB and TWS has been restored - data maintained.>\n***** STORE NOTIF: <error id=-1, errorCode=2106, errorMsg=HMDS data farm connection is OK:demohmds>\n***** STORE NOTIF: <error id=-1, errorCode=2104, errorMsg=Market data farm connection is OK:ibdemo>\n***** DATA NOTIF: DELAYED\n1444, 2016-06-20T18:16:40.000000, 16.04, 16.04, 16.03, 16.04, 0.0, 0, 15.986\n1445, 2016-06-20T18:16:45.000000, 16.03, 16.04, 16.03, 16.04, 0.0, 0, 15.986\n1446, 2016-06-20T18:16:50.000000, 16.04, 16.04, 16.03, 16.03, 0.0, 0, 15.982\n1447, 2016-06-20T18:16:55.000000, 16.04, 16.04, 16.03, 16.04, 0.0, 0, 16.01\n1448, 2016-06-20T18:17:00.000000, 16.03, 16.04, 16.03, 16.04, 0.0, 0, 16.038\n1449, 2016-06-20T18:17:05.000000, 16.03, 16.04, 16.02, 16.03, 0.0, 0, 16.036\n1450, 2016-06-20T18:17:10.000000, 15.9, 15.91, 15.9, 15.91, 3.0, 0, 16.01\n***** DATA NOTIF: LIVE\n1451, 2016-06-20T18:17:15.000000, 15.92, 15.92, 15.9, 15.92, 9.0, 0, 15.988\n1452, 2016-06-20T18:17:20.000000, 15.91, 15.91, 15.89, 15.89, 18.0, 0, 15.958\n1453, 2016-06-20T18:17:25.000000, 15.89, 15.92, 15.89, 15.89, 24.0, 0, 15.928\n...` \n```", "```py\n`./ibtest.py --port 7497 --data0 TWTR --resample --timeframe Seconds --compression 5 --broker --trade --stake 20000` \n```", "```py\n`...\n***** DATA NOTIF: LIVE\n1442, 2016-06-20T18:28:05.000000, 15.92, 15.93, 15.92, 15.93, 1748.0, 0, 16.03\n-------------------------------------------------- ORDER BEGIN 2016-06-20 23:28:11.343000\nRef: 1\nOrdType: 0\nOrdType: Buy\nStatus: 1\nStatus: Submitted\nSize: 20000\nPrice: 14.34\nPrice Limit: None\nExecType: 0\nExecType: Market\nCommInfo: <backtrader.brokers.ibbroker.IBCommInfo object at 0x00000000040B9278>\nEnd of Session: 736136.166655\nInfo: AutoOrderedDict()\nBroker: <backtrader.brokers.ibbroker.IBBroker object at 0x0000000003E23470>\nAlive: True\nRef: 1\norderId: 1\nAction: BUY\nSize (ib): 20000\nLmt Price: 0.0\nAux Price: 0.0\nOrderType: MKT\nTif (Time in Force): GTC\nGoodTillDate:\n-------------------------------------------------- ORDER END\n...\n1443, 2016-06-20T18:28:10.000000, 15.93, 15.93, 15.92, 15.92, 10.0, 0, 16.004\n-------------------------------------------------- ORDER BEGIN 2016-06-20 23:28:15.924000\nRef: 1\nOrdType: 0\nOrdType: Buy\nStatus: 3\nStatus: Partial\nSize: 20000\nPrice: 14.34\nPrice Limit: None\nExecType: 0\nExecType: Market\nCommInfo: <backtrader.brokers.ibbroker.IBCommInfo object at 0x00000000040B9278>\nEnd of Session: 736136.166655\nInfo: AutoOrderedDict()\nBroker: <backtrader.brokers.ibbroker.IBBroker object at 0x0000000003E23470>\nAlive: True\nRef: 1\norderId: 1\nAction: BUY\nSize (ib): 20000\nLmt Price: 0.0\nAux Price: 0.0\nOrderType: MKT\nTif (Time in Force): GTC\nGoodTillDate:\n-------------------------------------------------- ORDER END\n...\n-------------------------------------------------- ORDER BEGIN 2016-06-20 23:28:20.972000\nRef: 1\nOrdType: 0\nOrdType: Buy\nStatus: 4\nStatus: Completed\nSize: 20000\nPrice: 14.34\nPrice Limit: None\nExecType: 0\nExecType: Market\nCommInfo: <backtrader.brokers.ibbroker.IBCommInfo object at 0x00000000040B9278>\nEnd of Session: 736136.166655\nInfo: AutoOrderedDict()\nBroker: <backtrader.brokers.ibbroker.IBBroker object at 0x0000000003E23470>\nAlive: False\nRef: 1\norderId: 1\nAction: BUY\nSize (ib): 20000\nLmt Price: 0.0\nAux Price: 0.0\nOrderType: MKT\nTif (Time in Force): GTC\nGoodTillDate:\n-------------------------------------------------- ORDER END\n1445, 2016-06-20T18:28:20.000000, 15.92, 15.93, 15.92, 15.93, 21.0, 0, 15.954\n...` \n```", "```py\n`$ ./ibtest.py --help\nusage: ibtest.py [-h] [--exactbars EXACTBARS] [--plot] [--stopafter STOPAFTER]\n                 [--usestore] [--notifyall] [--debug] [--host HOST]\n                 [--qcheck QCHECK] [--port PORT] [--clientId CLIENTID]\n                 [--no-timeoffset] [--reconnect RECONNECT] [--timeout TIMEOUT]\n                 --data0 DATA0 [--data1 DATA1] [--timezone TIMEZONE]\n                 [--what WHAT] [--no-backfill_start] [--latethrough]\n                 [--no-backfill] [--rtbar] [--historical]\n                 [--fromdate FROMDATE] [--smaperiod SMAPERIOD]\n                 [--replay | --resample]\n                 [--timeframe {Ticks,MicroSeconds,Seconds,Minutes,Days,Weeks,Months,Years}]\n                 [--compression COMPRESSION] [--no-takelate] [--no-bar2edge]\n                 [--no-adjbartime] [--no-rightedge] [--broker] [--trade]\n                 [--donotsell]\n                 [--exectype {Market,Close,Limit,Stop,StopLimit}]\n                 [--stake STAKE] [--valid VALID] [--cancel CANCEL]\n\nTest Interactive Brokers integration\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --exactbars EXACTBARS\n                        exactbars level, use 0/-1/-2 to enable plotting\n                        (default: 1)\n  --plot                Plot if possible (default: False)\n  --stopafter STOPAFTER\n                        Stop after x lines of LIVE data (default: 0)\n  --usestore            Use the store pattern (default: False)\n  --notifyall           Notify all messages to strategy as store notifs\n                        (default: False)\n  --debug               Display all info received form IB (default: False)\n  --host HOST           Host for the Interactive Brokers TWS Connection\n                        (default: 127.0.0.1)\n  --qcheck QCHECK       Timeout for periodic notification/resampling/replaying\n                        check (default: 0.5)\n  --port PORT           Port for the Interactive Brokers TWS Connection\n                        (default: 7496)\n  --clientId CLIENTID   Client Id to connect to TWS (default: random)\n                        (default: None)\n  --no-timeoffset       Do not Use TWS/System time offset for non timestamped\n                        prices and to align resampling (default: False)\n  --reconnect RECONNECT\n                        Number of recconnection attempts to TWS (default: 3)\n  --timeout TIMEOUT     Timeout between reconnection attempts to TWS (default:\n                        3.0)\n  --data0 DATA0         data 0 into the system (default: None)\n  --data1 DATA1         data 1 into the system (default: None)\n  --timezone TIMEZONE   timezone to get time output into (pytz names)\n                        (default: None)\n  --what WHAT           specific price type for historical requests (default:\n                        None)\n  --no-backfill_start   Disable backfilling at the start (default: False)\n  --latethrough         if resampling replaying, adjusting time and disabling\n                        time offset, let late samples through (default: False)\n  --no-backfill         Disable backfilling after a disconnection (default:\n                        False)\n  --rtbar               Use 5 seconds real time bar updates if possible\n                        (default: False)\n  --historical          do only historical download (default: False)\n  --fromdate FROMDATE   Starting date for historical download with format:\n                        YYYY-MM-DD[THH:MM:SS] (default: None)\n  --smaperiod SMAPERIOD\n                        Period to apply to the Simple Moving Average (default:\n                        5)\n  --replay              replay to chosen timeframe (default: False)\n  --resample            resample to chosen timeframe (default: False)\n  --timeframe {Ticks,MicroSeconds,Seconds,Minutes,Days,Weeks,Months,Years}\n                        TimeFrame for Resample/Replay (default: Ticks)\n  --compression COMPRESSION\n                        Compression for Resample/Replay (default: 1)\n  --no-takelate         resample/replay, do not accept late samples in new bar\n                        if the data source let them through (latethrough)\n                        (default: False)\n  --no-bar2edge         no bar2edge for resample/replay (default: False)\n  --no-adjbartime       no adjbartime for resample/replay (default: False)\n  --no-rightedge        no rightedge for resample/replay (default: False)\n  --broker              Use IB as broker (default: False)\n  --trade               Do Sample Buy/Sell operations (default: False)\n  --donotsell           Do not sell after a buy (default: False)\n  --exectype {Market,Close,Limit,Stop,StopLimit}\n                        Execution to Use when opening position (default:\n                        Market)\n  --stake STAKE         Stake to use in buy operations (default: 10)\n  --valid VALID         Seconds to keep the order alive (0 means DAY)\n                        (default: None)\n  --cancel CANCEL       Cancel a buy order after n bars in operation, to be\n                        combined with orders like Limit (default: 0)` \n```", "```py\n`from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport argparse\nimport datetime\n\n# The above could be sent to an independent module\nimport backtrader as bt\nfrom backtrader.utils import flushfile  # win32 quick stdout flushing\n\nclass TestStrategy(bt.Strategy):\n    params = dict(\n        smaperiod=5,\n        trade=False,\n        stake=10,\n        exectype=bt.Order.Market,\n        stopafter=0,\n        valid=None,\n        cancel=0,\n        donotsell=False,\n    )\n\n    def __init__(self):\n        # To control operation entries\n        self.orderid = list()\n        self.order = None\n\n        self.counttostop = 0\n        self.datastatus = 0\n\n        # Create SMA on 2nd data\n        self.sma = bt.indicators.MovAv.SMA(self.data, period=self.p.smaperiod)\n\n        print('--------------------------------------------------')\n        print('Strategy Created')\n        print('--------------------------------------------------')\n\n    def notify_data(self, data, status, *args, **kwargs):\n        print('*' * 5, 'DATA NOTIF:', data._getstatusname(status), *args)\n        if status == data.LIVE:\n            self.counttostop = self.p.stopafter\n            self.datastatus = 1\n\n    def notify_store(self, msg, *args, **kwargs):\n        print('*' * 5, 'STORE NOTIF:', msg)\n\n    def notify_order(self, order):\n        if order.status in [order.Completed, order.Cancelled, order.Rejected]:\n            self.order = None\n\n        print('-' * 50, 'ORDER BEGIN', datetime.datetime.now())\n        print(order)\n        print('-' * 50, 'ORDER END')\n\n    def notify_trade(self, trade):\n        print('-' * 50, 'TRADE BEGIN', datetime.datetime.now())\n        print(trade)\n        print('-' * 50, 'TRADE END')\n\n    def prenext(self):\n        self.next(frompre=True)\n\n    def next(self, frompre=False):\n        txt = list()\n        txt.append('%04d' % len(self))\n        dtfmt = '%Y-%m-%dT%H:%M:%S.%f'\n        txt.append('%s' % self.data.datetime.datetime(0).strftime(dtfmt))\n        txt.append('{}'.format(self.data.open[0]))\n        txt.append('{}'.format(self.data.high[0]))\n        txt.append('{}'.format(self.data.low[0]))\n        txt.append('{}'.format(self.data.close[0]))\n        txt.append('{}'.format(self.data.volume[0]))\n        txt.append('{}'.format(self.data.openinterest[0]))\n        txt.append('{}'.format(self.sma[0]))\n        print(', '.join(txt))\n\n        if len(self.datas) > 1:\n            txt = list()\n            txt.append('%04d' % len(self))\n            dtfmt = '%Y-%m-%dT%H:%M:%S.%f'\n            txt.append('%s' % self.data1.datetime.datetime(0).strftime(dtfmt))\n            txt.append('{}'.format(self.data1.open[0]))\n            txt.append('{}'.format(self.data1.high[0]))\n            txt.append('{}'.format(self.data1.low[0]))\n            txt.append('{}'.format(self.data1.close[0]))\n            txt.append('{}'.format(self.data1.volume[0]))\n            txt.append('{}'.format(self.data1.openinterest[0]))\n            txt.append('{}'.format(float('NaN')))\n            print(', '.join(txt))\n\n        if self.counttostop:  # stop after x live lines\n            self.counttostop -= 1\n            if not self.counttostop:\n                self.env.runstop()\n                return\n\n        if not self.p.trade:\n            return\n\n        if self.datastatus and not self.position and len(self.orderid) < 1:\n            self.order = self.buy(size=self.p.stake,\n                                  exectype=self.p.exectype,\n                                  price=round(self.data0.close[0] * 0.90, 2),\n                                  valid=self.p.valid)\n\n            self.orderid.append(self.order)\n        elif self.position.size > 0 and not self.p.donotsell:\n            if self.order is None:\n                self.order = self.sell(size=self.p.stake // 2,\n                                       exectype=bt.Order.Market,\n                                       price=self.data0.close[0])\n\n        elif self.order is not None and self.p.cancel:\n            if self.datastatus > self.p.cancel:\n                self.cancel(self.order)\n\n        if self.datastatus:\n            self.datastatus += 1\n\n    def start(self):\n        if self.data0.contractdetails is not None:\n            print('Timezone from ContractDetails: {}'.format(\n                  self.data0.contractdetails.m_timeZoneId))\n\n        header = ['Datetime', 'Open', 'High', 'Low', 'Close', 'Volume',\n                  'OpenInterest', 'SMA']\n        print(', '.join(header))\n\n        self.done = False\n\ndef runstrategy():\n    args = parse_args()\n\n    # Create a cerebro\n    cerebro = bt.Cerebro()\n\n    storekwargs = dict(\n        host=args.host, port=args.port,\n        clientId=args.clientId, timeoffset=not args.no_timeoffset,\n        reconnect=args.reconnect, timeout=args.timeout,\n        notifyall=args.notifyall, _debug=args.debug\n    )\n\n    if args.usestore:\n        ibstore = bt.stores.IBStore(**storekwargs)\n\n    if args.broker:\n        if args.usestore:\n            broker = ibstore.getbroker()\n        else:\n            broker = bt.brokers.IBBroker(**storekwargs)\n\n        cerebro.setbroker(broker)\n\n    timeframe = bt.TimeFrame.TFrame(args.timeframe)\n    if args.resample or args.replay:\n        datatf = bt.TimeFrame.Ticks\n        datacomp = 1\n    else:\n        datatf = timeframe\n        datacomp = args.compression\n\n    fromdate = None\n    if args.fromdate:\n        dtformat = '%Y-%m-%d' + ('T%H:%M:%S' * ('T' in args.fromdate))\n        fromdate = datetime.datetime.strptime(args.fromdate, dtformat)\n\n    IBDataFactory = ibstore.getdata if args.usestore else bt.feeds.IBData\n\n    datakwargs = dict(\n        timeframe=datatf, compression=datacomp,\n        historical=args.historical, fromdate=fromdate,\n        rtbar=args.rtbar,\n        qcheck=args.qcheck,\n        what=args.what,\n        backfill_start=not args.no_backfill_start,\n        backfill=not args.no_backfill,\n        latethrough=args.latethrough,\n        tz=args.timezone\n    )\n\n    if not args.usestore and not args.broker:   # neither store nor broker\n        datakwargs.update(storekwargs)  # pass the store args over the data\n\n    data0 = IBDataFactory(dataname=args.data0, **datakwargs)\n\n    data1 = None\n    if args.data1 is not None:\n        data1 = IBDataFactory(dataname=args.data1, **datakwargs)\n\n    rekwargs = dict(\n        timeframe=timeframe, compression=args.compression,\n        bar2edge=not args.no_bar2edge,\n        adjbartime=not args.no_adjbartime,\n        rightedge=not args.no_rightedge,\n        takelate=not args.no_takelate,\n    )\n\n    if args.replay:\n        cerebro.replaydata(dataname=data0, **rekwargs)\n\n        if data1 is not None:\n            cerebro.replaydata(dataname=data1, **rekwargs)\n\n    elif args.resample:\n        cerebro.resampledata(dataname=data0, **rekwargs)\n\n        if data1 is not None:\n            cerebro.resampledata(dataname=data1, **rekwargs)\n\n    else:\n        cerebro.adddata(data0)\n        if data1 is not None:\n            cerebro.adddata(data1)\n\n    if args.valid is None:\n        valid = None\n    else:\n        datetime.timedelta(seconds=args.valid)\n    # Add the strategy\n    cerebro.addstrategy(TestStrategy,\n                        smaperiod=args.smaperiod,\n                        trade=args.trade,\n                        exectype=bt.Order.ExecType(args.exectype),\n                        stake=args.stake,\n                        stopafter=args.stopafter,\n                        valid=valid,\n                        cancel=args.cancel,\n                        donotsell=args.donotsell)\n\n    # Live data ... avoid long data accumulation by switching to \"exactbars\"\n    cerebro.run(exactbars=args.exactbars)\n\n    if args.plot and args.exactbars < 1:  # plot if possible\n        cerebro.plot()\n\ndef parse_args():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n        description='Test Interactive Brokers integration')\n\n    parser.add_argument('--exactbars', default=1, type=int,\n                        required=False, action='store',\n                        help='exactbars level, use 0/-1/-2 to enable plotting')\n\n    parser.add_argument('--plot',\n                        required=False, action='store_true',\n                        help='Plot if possible')\n\n    parser.add_argument('--stopafter', default=0, type=int,\n                        required=False, action='store',\n                        help='Stop after x lines of LIVE data')\n\n    parser.add_argument('--usestore',\n                        required=False, action='store_true',\n                        help='Use the store pattern')\n\n    parser.add_argument('--notifyall',\n                        required=False, action='store_true',\n                        help='Notify all messages to strategy as store notifs')\n\n    parser.add_argument('--debug',\n                        required=False, action='store_true',\n                        help='Display all info received form IB')\n\n    parser.add_argument('--host', default='127.0.0.1',\n                        required=False, action='store',\n                        help='Host for the Interactive Brokers TWS Connection')\n\n    parser.add_argument('--qcheck', default=0.5, type=float,\n                        required=False, action='store',\n                        help=('Timeout for periodic '\n                              'notification/resampling/replaying check'))\n\n    parser.add_argument('--port', default=7496, type=int,\n                        required=False, action='store',\n                        help='Port for the Interactive Brokers TWS Connection')\n\n    parser.add_argument('--clientId', default=None, type=int,\n                        required=False, action='store',\n                        help='Client Id to connect to TWS (default: random)')\n\n    parser.add_argument('--no-timeoffset',\n                        required=False, action='store_true',\n                        help=('Do not Use TWS/System time offset for non '\n                              'timestamped prices and to align resampling'))\n\n    parser.add_argument('--reconnect', default=3, type=int,\n                        required=False, action='store',\n                        help='Number of recconnection attempts to TWS')\n\n    parser.add_argument('--timeout', default=3.0, type=float,\n                        required=False, action='store',\n                        help='Timeout between reconnection attempts to TWS')\n\n    parser.add_argument('--data0', default=None,\n                        required=True, action='store',\n                        help='data 0 into the system')\n\n    parser.add_argument('--data1', default=None,\n                        required=False, action='store',\n                        help='data 1 into the system')\n\n    parser.add_argument('--timezone', default=None,\n                        required=False, action='store',\n                        help='timezone to get time output into (pytz names)')\n\n    parser.add_argument('--what', default=None,\n                        required=False, action='store',\n                        help='specific price type for historical requests')\n\n    parser.add_argument('--no-backfill_start',\n                        required=False, action='store_true',\n                        help='Disable backfilling at the start')\n\n    parser.add_argument('--latethrough',\n                        required=False, action='store_true',\n                        help=('if resampling replaying, adjusting time '\n                              'and disabling time offset, let late samples '\n                              'through'))\n\n    parser.add_argument('--no-backfill',\n                        required=False, action='store_true',\n                        help='Disable backfilling after a disconnection')\n\n    parser.add_argument('--rtbar', default=False,\n                        required=False, action='store_true',\n                        help='Use 5 seconds real time bar updates if possible')\n\n    parser.add_argument('--historical',\n                        required=False, action='store_true',\n                        help='do only historical download')\n\n    parser.add_argument('--fromdate',\n                        required=False, action='store',\n                        help=('Starting date for historical download '\n                              'with format: YYYY-MM-DD[THH:MM:SS]'))\n\n    parser.add_argument('--smaperiod', default=5, type=int,\n                        required=False, action='store',\n                        help='Period to apply to the Simple Moving Average')\n\n    pgroup = parser.add_mutually_exclusive_group(required=False)\n\n    pgroup.add_argument('--replay',\n                        required=False, action='store_true',\n                        help='replay to chosen timeframe')\n\n    pgroup.add_argument('--resample',\n                        required=False, action='store_true',\n                        help='resample to chosen timeframe')\n\n    parser.add_argument('--timeframe', default=bt.TimeFrame.Names[0],\n                        choices=bt.TimeFrame.Names,\n                        required=False, action='store',\n                        help='TimeFrame for Resample/Replay')\n\n    parser.add_argument('--compression', default=1, type=int,\n                        required=False, action='store',\n                        help='Compression for Resample/Replay')\n\n    parser.add_argument('--no-takelate',\n                        required=False, action='store_true',\n                        help=('resample/replay, do not accept late samples '\n                              'in new bar if the data source let them through '\n                              '(latethrough)'))\n\n    parser.add_argument('--no-bar2edge',\n                        required=False, action='store_true',\n                        help='no bar2edge for resample/replay')\n\n    parser.add_argument('--no-adjbartime',\n                        required=False, action='store_true',\n                        help='no adjbartime for resample/replay')\n\n    parser.add_argument('--no-rightedge',\n                        required=False, action='store_true',\n                        help='no rightedge for resample/replay')\n\n    parser.add_argument('--broker',\n                        required=False, action='store_true',\n                        help='Use IB as broker')\n\n    parser.add_argument('--trade',\n                        required=False, action='store_true',\n                        help='Do Sample Buy/Sell operations')\n\n    parser.add_argument('--donotsell',\n                        required=False, action='store_true',\n                        help='Do not sell after a buy')\n\n    parser.add_argument('--exectype', default=bt.Order.ExecTypes[0],\n                        choices=bt.Order.ExecTypes,\n                        required=False, action='store',\n                        help='Execution to Use when opening position')\n\n    parser.add_argument('--stake', default=10, type=int,\n                        required=False, action='store',\n                        help='Stake to use in buy operations')\n\n    parser.add_argument('--valid', default=None, type=int,\n                        required=False, action='store',\n                        help='Seconds to keep the order alive (0 means DAY)')\n\n    parser.add_argument('--cancel', default=0, type=int,\n                        required=False, action='store',\n                        help=('Cancel a buy order after n bars in operation,'\n                              ' to be combined with orders like Limit'))\n\n    return parser.parse_args()\n\nif __name__ == '__main__':\n    runstrategy()` \n```"]