["```py\n`data = MyDataFeed(name=myname)\n\ndata.addfilter(filter, *args, **kwargs)` \n```", "```py\n    `callable(data, *args, **kwargs)` \n    ```", "```py\n    `def __init__(self, data, *args, **kwargs)` \n    ```", "```py\n    `def __call__(self, data)\n\n    def last(self, data)` \n    ```", "```py\n`class SessionFilter(with_metaclass(metabase.MetaParams, object)):\n    '''\n    This class can be applied to a data source as a filter and will filter out\n    intraday bars which fall outside of the regular session times (ie: pre/post\n    market data)\n\n    This is a \"non-simple\" filter and must manage the stack of the data (passed\n    during init and __call__)\n\n    It needs no \"last\" method because it has nothing to deliver\n    '''\n    def __init__(self, data):\n        pass\n\n    def __call__(self, data):\n        '''\n        Return Values:\n\n          - False: data stream was not touched\n          - True: data stream was manipulated (bar outside of session times and\n          - removed)\n        '''\n        if data.sessionstart <= data.datetime.tm(0) <= data.sessionend:\n            # Both ends of the comparison are in the session\n            return False  # say the stream is untouched\n\n        # bar outside of the regular session times\n        data.backwards()  # remove bar from data stack\n        return True  # signal the data was manipulated` \n```", "```py\n`$ ./data-filler.py --writer --wrcsv` \n```", "```py\n`===============================================================================\nId,2006-01-02-volume-min-001,len,datetime,open,high,low,close,volume,openinterest,Strategy,len\n1,2006-01-02-volume-min-001,1,2006-01-02 09:01:00,3602.0,3603.0,3597.0,3599.0,5699.0,0.0,Strategy,1\n2,2006-01-02-volume-min-001,2,2006-01-02 09:02:00,3600.0,3601.0,3598.0,3599.0,894.0,0.0,Strategy,2\n...\n...\n581,2006-01-02-volume-min-001,581,2006-01-02 19:59:00,3619.0,3619.0,3619.0,3619.0,1.0,0.0,Strategy,581\n582,2006-01-02-volume-min-001,582,2006-01-02 20:00:00,3618.0,3618.0,3617.0,3618.0,242.0,0.0,Strategy,582\n583,2006-01-02-volume-min-001,583,2006-01-02 20:01:00,3618.0,3618.0,3617.0,3617.0,15.0,0.0,Strategy,583\n584,2006-01-02-volume-min-001,584,2006-01-02 20:04:00,3617.0,3617.0,3617.0,3617.0,107.0,0.0,Strategy,584\n585,2006-01-02-volume-min-001,585,2006-01-03 09:01:00,3623.0,3625.0,3622.0,3624.0,4026.0,0.0,Strategy,585\n...` \n```", "```py\n`$ ./data-filler.py --writer --wrcsv --tstart 09:30 --tend 17:30 --filter\n\n===============================================================================\nId,2006-01-02-volume-min-001,len,datetime,open,high,low,close,volume,openinterest,Strategy,len\n1,2006-01-02-volume-min-001,1,2006-01-02 09:30:00,3604.0,3605.0,3603.0,3604.0,546.0,0.0,Strategy,1\n2,2006-01-02-volume-min-001,2,2006-01-02 09:31:00,3604.0,3606.0,3604.0,3606.0,438.0,0.0,Strategy,2\n...\n...\n445,2006-01-02-volume-min-001,445,2006-01-02 17:29:00,3621.0,3621.0,3620.0,3620.0,866.0,0.0,Strategy,445\n446,2006-01-02-volume-min-001,446,2006-01-02 17:30:00,3620.0,3621.0,3619.0,3621.0,1670.0,0.0,Strategy,446\n447,2006-01-02-volume-min-001,447,2006-01-03 09:30:00,3637.0,3638.0,3635.0,3636.0,1458.0,0.0,Strategy,447\n...` \n```", "```py\n`...\n61,2006-01-02-volume-min-001,61,2006-01-02 10:30:00,3613.0,3614.0,3613.0,3614.0,112.0,0.0,Strategy,61\n62,2006-01-02-volume-min-001,62,2006-01-02 10:31:00,3614.0,3614.0,3614.0,3614.0,183.0,0.0,Strategy,62\n63,2006-01-02-volume-min-001,63,2006-01-02 10:34:00,3614.0,3614.0,3614.0,3614.0,841.0,0.0,Strategy,63\n64,2006-01-02-volume-min-001,64,2006-01-02 10:35:00,3614.0,3614.0,3614.0,3614.0,17.0,0.0,Strategy,64\n...` \n```", "```py\n`class SessionFiller(with_metaclass(metabase.MetaParams, object)):\n    '''\n    Bar Filler for a Data Source inside the declared session start/end times.\n\n    The fill bars are constructed using the declared Data Source ``timeframe``\n    and ``compression`` (used to calculate the intervening missing times)\n\n    Params:\n\n      - fill_price (def: None):\n\n        If None is passed, the closing price of the previous bar will be\n        used. To end up with a bar which for example takes time but it is not\n        displayed in a plot ... use float('Nan')\n\n      - fill_vol (def: float('NaN')):\n\n        Value to use to fill the missing volume\n\n      - fill_oi (def: float('NaN')):\n\n        Value to use to fill the missing Open Interest\n\n      - skip_first_fill (def: True):\n\n        Upon seeing the 1st valid bar do not fill from the sessionstart up to\n        that bar\n    '''\n    params = (('fill_price', None),\n              ('fill_vol', float('NaN')),\n              ('fill_oi', float('NaN')),\n              ('skip_first_fill', True))` \n```", "```py\n`./data-filler.py --writer --wrcsv --tstart 09:30 --tend 17:30 --filter --filler\n\n...\n62,2006-01-02-volume-min-001,62,2006-01-02 10:31:00,3614.0,3614.0,3614.0,3614.0,183.0,0.0,Strategy,62\n63,2006-01-02-volume-min-001,63,2006-01-02 10:32:00,3614.0,3614.0,3614.0,3614.0,0.0,,Strategy,63\n64,2006-01-02-volume-min-001,64,2006-01-02 10:33:00,3614.0,3614.0,3614.0,3614.0,0.0,,Strategy,64\n65,2006-01-02-volume-min-001,65,2006-01-02 10:34:00,3614.0,3614.0,3614.0,3614.0,841.0,0.0,Strategy,65\n...` \n```", "```py\n`class RelativeVolume(bt.Indicator):\n    csv = True  # show up in csv output (default for indicators is False)\n\n    lines = ('relvol',)\n    params = (\n        ('period', 20),\n        ('volisnan', True),\n    )\n\n    def __init__(self):\n        if self.p.volisnan:\n            # if missing volume will be NaN, do a simple division\n            # the end result for missing volumes will also be NaN\n            relvol = self.data.volume(-self.p.period) / self.data.volume\n        else:\n            # Else do a controlled Div with a built-in function\n            relvol = bt.DivByZero(\n                self.data.volume(-self.p.period),\n                self.data.volume,\n                zero=0.0)\n\n        self.lines.relvol = relvol` \n```", "```py\n`./data-filler.py --writer --wrcsv --tstart 09:30 --tend 17:30 --filter --filler --relvol\n\n===============================================================================\nId,2006-01-02-volume-min-001,len,datetime,open,high,low,close,volume,openinterest,Strategy,len,RelativeVolume,len,relvol\n1,2006-01-02-volume-min-001,1,2006-01-02 09:30:00,3604.0,3605.0,3603.0,3604.0,546.0,0.0,Strategy,1,RelativeVolume,1,\n2,2006-01-02-volume-min-001,2,2006-01-02 09:31:00,3604.0,3606.0,3604.0,3606.0,438.0,0.0,Strategy,2,RelativeVolume,2,\n...` \n```", "```py\n`...\n543,2006-01-02-volume-min-001,543,2006-01-03 10:31:00,3648.0,3648.0,3647.0,3648.0,56.0,0.0,Strategy,543,RelativeVolume,543,3.26785714286\n544,2006-01-02-volume-min-001,544,2006-01-03 10:32:00,3647.0,3648.0,3647.0,3647.0,313.0,0.0,Strategy,544,RelativeVolume,544,0.0\n545,2006-01-02-volume-min-001,545,2006-01-03 10:33:00,3647.0,3647.0,3647.0,3647.0,135.0,0.0,Strategy,545,RelativeVolume,545,0.0\n546,2006-01-02-volume-min-001,546,2006-01-03 10:34:00,3648.0,3648.0,3647.0,3648.0,171.0,0.0,Strategy,546,RelativeVolume,546,4.91812865497\n...` \n```", "```py\n`usage: data-filler.py [-h] [--data DATA] [--filter] [--filler] [--fvol FVOL]\n                      [--tstart TSTART] [--tend TEND] [--relvol]\n                      [--fromdate FROMDATE] [--todate TODATE] [--writer]\n                      [--wrcsv] [--plot] [--numfigs NUMFIGS]\n\nDataFilter/DataFiller Sample\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --data DATA, -d DATA  data to add to the system\n  --filter, -ft         Filter using session start/end times\n  --filler, -fl         Fill missing bars inside start/end times\n  --fvol FVOL           Use as fill volume for missing bar (def: 0.0)\n  --tstart TSTART, -ts TSTART\n                        Start time for the Session Filter (HH:MM)\n  --tend TEND, -te TEND\n                        End time for the Session Filter (HH:MM)\n  --relvol, -rv         Add relative volume indicator\n  --fromdate FROMDATE, -f FROMDATE\n                        Starting date in YYYY-MM-DD format\n  --todate TODATE, -t TODATE\n                        Starting date in YYYY-MM-DD format\n  --writer, -w          Add a writer to cerebro\n  --wrcsv, -wc          Enable CSV Output in the writer\n  --plot, -p            Plot the read data\n  --numfigs NUMFIGS, -n NUMFIGS\n                        Plot using numfigs figures` \n```", "```py\n`from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport argparse\nimport datetime\nimport math\n\n# The above could be sent to an independent module\nimport backtrader as bt\nimport backtrader.feeds as btfeeds\nimport backtrader.utils.flushfile\nimport backtrader.filters as btfilters\n\nfrom relativevolume import RelativeVolume\n\ndef runstrategy():\n    args = parse_args()\n\n    # Create a cerebro\n    cerebro = bt.Cerebro()\n\n    # Get the dates from the args\n    fromdate = datetime.datetime.strptime(args.fromdate, '%Y-%m-%d')\n    todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')\n\n    # Get the session times to pass them to the indicator\n    # datetime.time has no strptime ...\n    dtstart = datetime.datetime.strptime(args.tstart, '%H:%M')\n    dtend = datetime.datetime.strptime(args.tend, '%H:%M')\n\n    # Create the 1st data\n    data = btfeeds.BacktraderCSVData(\n        dataname=args.data,\n        fromdate=fromdate,\n        todate=todate,\n        timeframe=bt.TimeFrame.Minutes,\n        compression=1,\n        sessionstart=dtstart,  # internally just the \"time\" part will be used\n        sessionend=dtend,  # internally just the \"time\" part will be used\n    )\n\n    if args.filter:\n        data.addfilter(btfilters.SessionFilter)\n\n    if args.filler:\n        data.addfilter(btfilters.SessionFiller, fill_vol=args.fvol)\n\n    # Add the data to cerebro\n    cerebro.adddata(data)\n\n    if args.relvol:\n        # Calculate backward period - tend tstart are in same day\n        # + 1 to include last moment of the interval dstart <-> dtend\n        td = ((dtend - dtstart).seconds // 60) + 1\n        cerebro.addindicator(RelativeVolume,\n                             period=td,\n                             volisnan=math.isnan(args.fvol))\n\n    # Add an empty strategy\n    cerebro.addstrategy(bt.Strategy)\n\n    # Add a writer with CSV\n    if args.writer:\n        cerebro.addwriter(bt.WriterFile, csv=args.wrcsv)\n\n    # And run it - no trading - disable stdstats\n    cerebro.run(stdstats=False)\n\n    # Plot if requested\n    if args.plot:\n        cerebro.plot(numfigs=args.numfigs, volume=True)\n\ndef parse_args():\n    parser = argparse.ArgumentParser(\n        description='DataFilter/DataFiller Sample')\n\n    parser.add_argument('--data', '-d',\n                        default='../../datas/2006-01-02-volume-min-001.txt',\n                        help='data to add to the system')\n\n    parser.add_argument('--filter', '-ft', action='store_true',\n                        help='Filter using session start/end times')\n\n    parser.add_argument('--filler', '-fl', action='store_true',\n                        help='Fill missing bars inside start/end times')\n\n    parser.add_argument('--fvol', required=False, default=0.0,\n                        type=float,\n                        help='Use as fill volume for missing bar (def: 0.0)')\n\n    parser.add_argument('--tstart', '-ts',\n                        # default='09:14:59',\n                        # help='Start time for the Session Filter (%H:%M:%S)')\n                        default='09:15',\n                        help='Start time for the Session Filter (HH:MM)')\n\n    parser.add_argument('--tend', '-te',\n                        # default='17:15:59',\n                        # help='End time for the Session Filter (%H:%M:%S)')\n                        default='17:15',\n                        help='End time for the Session Filter (HH:MM)')\n\n    parser.add_argument('--relvol', '-rv', action='store_true',\n                        help='Add relative volume indicator')\n\n    parser.add_argument('--fromdate', '-f',\n                        default='2006-01-01',\n                        help='Starting date in YYYY-MM-DD format')\n\n    parser.add_argument('--todate', '-t',\n                        default='2006-12-31',\n                        help='Starting date in YYYY-MM-DD format')\n\n    parser.add_argument('--writer', '-w', action='store_true',\n                        help='Add a writer to cerebro')\n\n    parser.add_argument('--wrcsv', '-wc', action='store_true',\n                        help='Enable CSV Output in the writer')\n\n    parser.add_argument('--plot', '-p', action='store_true',\n                        help='Plot the read data')\n\n    parser.add_argument('--numfigs', '-n', default=1,\n                        help='Plot using numfigs figures')\n\n    return parser.parse_args()\n\nif __name__ == '__main__':\n    runstrategy()` \n```", "```py\n`class SessionFiller(with_metaclass(metabase.MetaParams, object)):\n    '''\n    Bar Filler for a Data Source inside the declared session start/end times.\n\n    The fill bars are constructed using the declared Data Source ``timeframe``\n    and ``compression`` (used to calculate the intervening missing times)\n\n    Params:\n\n      - fill_price (def: None):\n\n        If None is passed, the closing price of the previous bar will be\n        used. To end up with a bar which for example takes time but it is not\n        displayed in a plot ... use float('Nan')\n\n      - fill_vol (def: float('NaN')):\n\n        Value to use to fill the missing volume\n\n      - fill_oi (def: float('NaN')):\n\n        Value to use to fill the missing Open Interest\n\n      - skip_first_fill (def: True):\n\n        Upon seeing the 1st valid bar do not fill from the sessionstart up to\n        that bar\n    '''\n    params = (('fill_price', None),\n              ('fill_vol', float('NaN')),\n              ('fill_oi', float('NaN')),\n              ('skip_first_fill', True))\n\n    # Minimum delta unit in between bars\n    _tdeltas = {\n        TimeFrame.Minutes: datetime.timedelta(seconds=60),\n        TimeFrame.Seconds: datetime.timedelta(seconds=1),\n        TimeFrame.MicroSeconds: datetime.timedelta(microseconds=1),\n    }\n\n    def __init__(self, data):\n        # Calculate and save timedelta for timeframe\n        self._tdunit = self._tdeltas[data._timeframe] * data._compression\n\n        self.seenbar = False  # control if at least one bar has been seen\n        self.sessend = MAXDATE  # maxdate is the control for bar in session\n\n    def __call__(self, data):\n        '''\n        Params:\n          - data: the data source to filter/process\n\n        Returns:\n          - False (always) because this filter does not remove bars from the\n        stream\n\n        The logic (starting with a session end control flag of MAXDATE)\n\n          - If new bar is over session end (never true for 1st bar)\n\n            Fill up to session end. Reset sessionend to MAXDATE & fall through\n\n          - If session end is flagged as MAXDATE\n\n            Recalculate session limits and check whether the bar is within them\n\n            if so, fill up and record the last seen tim\n\n          - Else ... the incoming bar is in the session, fill up to it\n        '''\n        # Get time of current (from data source) bar\n        dtime_cur = data.datetime.datetime()\n\n        if dtime_cur > self.sessend:\n            # bar over session end - fill up and invalidate\n            self._fillbars(data, self.dtime_prev, self.sessend + self._tdunit)\n            self.sessend = MAXDATE\n\n        # Fall through from previous check ... the bar which is over the\n        # session could already be in a new session and within the limits\n        if self.sessend == MAXDATE:\n            # No bar seen yet or one went over previous session limit\n            sessstart = data.datetime.tm2datetime(data.sessionstart)\n            self.sessend = sessend = data.datetime.tm2datetime(data.sessionend)\n\n            if sessstart <= dtime_cur <= sessend:\n                # 1st bar from session in the session - fill from session start\n                if self.seenbar or not self.p.skip_first_fill:\n                    self._fillbars(data, sessstart - self._tdunit, dtime_cur)\n\n            self.seenbar = True\n            self.dtime_prev = dtime_cur\n\n        else:\n            # Seen a previous bar and this is in the session - fill up to it\n            self._fillbars(data, self.dtime_prev, dtime_cur)\n            self.dtime_prev = dtime_cur\n\n        return False\n\n    def _fillbars(self, data, time_start, time_end, forcedirty=False):\n        '''\n        Fills one by one bars as needed from time_start to time_end\n\n        Invalidates the control dtime_prev if requested\n        '''\n        # Control flag - bars added to the stack\n        dirty = False\n\n        time_start += self._tdunit\n        while time_start < time_end:\n            dirty = self._fillbar(data, time_start)\n            time_start += self._tdunit\n\n        if dirty or forcedirty:\n            data._save2stack(erase=True)\n\n    def _fillbar(self, data, dtime):\n        # Prepare an array of the needed size\n        bar = [float('Nan')] * data.size()\n\n        # Fill datetime\n        bar[data.DateTime] = date2num(dtime)\n\n        # Fill the prices\n        price = self.p.fill_price or data.close[-1]\n        for pricetype in [data.Open, data.High, data.Low, data.Close]:\n            bar[pricetype] = price\n\n        # Fill volume and open interest\n        bar[data.Volume] = self.p.fill_vol\n        bar[data.OpenInterest] = self.p.fill_oi\n\n        # Fill extra lines the data feed may have defined beyond DateTime\n        for i in range(data.DateTime + 1, data.size()):\n            bar[i] = data.lines[i][0]\n\n        # Add tot he stack of bars to save\n        data._add2stack(bar)\n\n        return True` \n```"]