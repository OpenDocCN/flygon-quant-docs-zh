["```py\n`from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport collections\nimport datetime\nimport math\n\nimport backtrader as bt\n\ndef time2num(tm):\n    \"\"\"\n    Convert :mod:`time` to the to the preserving hours, minutes, seconds\n    and microseconds.  Return value is a :func:`float`.\n    \"\"\"\n    HOURS_PER_DAY = 24.0\n    MINUTES_PER_HOUR = 60.0\n    SECONDS_PER_MINUTE = 60.0\n    MUSECONDS_PER_SECOND = 1e6\n    MINUTES_PER_DAY = MINUTES_PER_HOUR * HOURS_PER_DAY\n    SECONDS_PER_DAY = SECONDS_PER_MINUTE * MINUTES_PER_DAY\n    MUSECONDS_PER_DAY = MUSECONDS_PER_SECOND * SECONDS_PER_DAY\n\n    tm_num = (tm.hour / HOURS_PER_DAY +\n              tm.minute / MINUTES_PER_DAY +\n              tm.second / SECONDS_PER_DAY +\n              tm.microsecond / MUSECONDS_PER_DAY)\n\n    return tm_num\n\ndef dtime_dt(dt):\n    return math.trunc(dt)\n\ndef dtime_tm(dt):\n    return math.modf(dt)[0]\n\nclass RelativeVolumeByBar(bt.Indicator):\n    alias = ('RVBB',)\n    lines = ('rvbb',)\n\n    params = (\n        ('prestart', datetime.time(8, 00)),\n        ('start', datetime.time(9, 10)),\n        ('end', datetime.time(17, 15)),\n    )\n\n    def _plotlabel(self):\n        plabels = []\n        for name, value in self.params._getitems():\n            plabels.append('%s: %s' % (name, value.strftime('%H:%M')))\n\n        return plabels\n\n    def __init__(self):\n        # Inform the platform about the minimum period needs\n        minbuffer = self._calcbuffer()\n        self.addminperiod(minbuffer)\n\n        # Structures/variable to keep synchronization\n        self.pvol = dict()\n        self.vcount = collections.defaultdict(int)\n\n        self.days = 0\n        self.dtlast = 0\n\n        # Keep the start/end times in numeric format for comparison\n        self.start = time2num(self.p.start)\n        self.end = time2num(self.p.end)\n\n        # Done after calc to ensure coop inheritance and composition work\n        super(RelativeVolumeByBar, self).__init__()\n\n    def _barisvalid(self, tm):\n        return self.start <= tm <= self.end\n\n    def _daycount(self):\n        dt = dtime_dt(self.data.datetime[0])\n        if dt > self.dtlast:\n            self.days += 1\n            self.dtlast = dt\n\n    def prenext(self):\n        self._daycount()\n\n        tm = dtime_tm(self.data.datetime[0])\n        if self._barisvalid(tm):\n            self.pvol[tm] = self.data.volume[0]\n            self.vcount[tm] += 1\n\n    def next(self):\n        self._daycount()\n\n        tm = dtime_tm(self.data.datetime[0])\n        if not self._barisvalid(tm):\n            return\n\n        # Record the \"minute/second\" of this day has been seen\n        self.vcount[tm] += 1\n\n        # Get the bar's volume\n        vol = self.data.volume[0]\n\n        # If number of days is right, we saw the same \"minute/second\" last day\n        if self.vcount[tm] == self.days:\n            self.lines.rvbb[0] = vol / self.pvol[tm]\n\n        # Synchronize the days and volume count for next cycle\n        self.vcount[tm] = self.days\n\n        # Record the volume for this bar for next cycle\n        self.pvol[tm] = vol\n\n    def _calcbuffer(self):\n        # Period calculation\n        minend = self.p.end.hour * 60 + self.p.end.minute\n        # minstart = session_start.hour * 60 + session_start.minute\n        # use prestart to account for market_data\n        minstart = self.p.prestart.hour * 60 + self.p.prestart.minute\n\n        minbuffer = minend - minstart\n\n        tframe = self.data._timeframe\n        tcomp = self.data._compression\n\n        if tframe == bt.TimeFrame.Seconds:\n            minbuffer = (minperiod * 60)\n\n        minbuffer = (minbuffer // tcomp) + tcomp\n\n        return minbuffer` \n```", "```py\n`$ ./relative-volume.py --help\nusage: relative-volume.py [-h] [--data DATA] [--prestart PRESTART]\n                          [--start START] [--end END] [--fromdate FROMDATE]\n                          [--todate TODATE] [--writer] [--wrcsv] [--plot]\n                          [--numfigs NUMFIGS]\n\nMultiData Strategy\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --data DATA, -d DATA  data to add to the system\n  --prestart PRESTART   Start time for the Session Filter\n  --start START         Start time for the Session Filter\n  --end END, -te END    End time for the Session Filter\n  --fromdate FROMDATE, -f FROMDATE\n                        Starting date in YYYY-MM-DD format\n  --todate TODATE, -t TODATE\n                        Starting date in YYYY-MM-DD format\n  --writer, -w          Add a writer to cerebro\n  --wrcsv, -wc          Enable CSV Output in the writer\n  --plot, -p            Plot the read data\n  --numfigs NUMFIGS, -n NUMFIGS\n                        Plot using numfigs figures` \n```", "```py\n`$ ./relative-volume.py --plot` \n```", "```py\n`from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport argparse\nimport datetime\n\n# The above could be sent to an independent module\nimport backtrader as bt\nimport backtrader.feeds as btfeeds\n\nfrom relvolbybar import RelativeVolumeByBar\n\ndef runstrategy():\n    args = parse_args()\n\n    # Create a cerebro\n    cerebro = bt.Cerebro()\n\n    # Get the dates from the args\n    fromdate = datetime.datetime.strptime(args.fromdate, '%Y-%m-%d')\n    todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')\n\n    # Create the 1st data\n    data = btfeeds.VChartCSVData(\n        dataname=args.data,\n        fromdate=fromdate,\n        todate=todate,\n        )\n\n    # Add the 1st data to cerebro\n    cerebro.adddata(data)\n\n    # Add an empty strategy\n    cerebro.addstrategy(bt.Strategy)\n\n    # Get the session times to pass them to the indicator\n    prestart = datetime.datetime.strptime(args.prestart, '%H:%M')\n    start = datetime.datetime.strptime(args.start, '%H:%M')\n    end = datetime.datetime.strptime(args.end, '%H:%M')\n\n    # Add the Relative volume indicator\n    cerebro.addindicator(RelativeVolumeByBar,\n                         prestart=prestart, start=start, end=end)\n\n    # Add a writer with CSV\n    if args.writer:\n        cerebro.addwriter(bt.WriterFile, csv=args.wrcsv)\n\n    # And run it\n    cerebro.run(stdstats=False)\n\n    # Plot if requested\n    if args.plot:\n        cerebro.plot(numfigs=args.numfigs, volume=True)\n\ndef parse_args():\n    parser = argparse.ArgumentParser(description='MultiData Strategy')\n\n    parser.add_argument('--data', '-d',\n                        default='../../datas/2006-01-02-volume-min-001.txt',\n                        help='data to add to the system')\n\n    parser.add_argument('--prestart',\n                        default='08:00',\n                        help='Start time for the Session Filter')\n\n    parser.add_argument('--start',\n                        default='09:15',\n                        help='Start time for the Session Filter')\n\n    parser.add_argument('--end', '-te',\n                        default='17:15',\n                        help='End time for the Session Filter')\n\n    parser.add_argument('--fromdate', '-f',\n                        default='2006-01-01',\n                        help='Starting date in YYYY-MM-DD format')\n\n    parser.add_argument('--todate', '-t',\n                        default='2006-12-31',\n                        help='Starting date in YYYY-MM-DD format')\n\n    parser.add_argument('--writer', '-w', action='store_true',\n                        help='Add a writer to cerebro')\n\n    parser.add_argument('--wrcsv', '-wc', action='store_true',\n                        help='Enable CSV Output in the writer')\n\n    parser.add_argument('--plot', '-p', action='store_true',\n                        help='Plot the read data')\n\n    parser.add_argument('--numfigs', '-n', default=1,\n                        help='Plot using numfigs figures')\n\n    return parser.parse_args()\n\nif __name__ == '__main__':\n    runstrategy()` \n```"]