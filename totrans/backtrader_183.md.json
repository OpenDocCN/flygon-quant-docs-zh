["```py\n`bt-run.py \\\n    --csvformat vchartcsv \\\n    --data ../datas/sample/1998-2015-estx50-vchart.txt \\\n    --analyzer legdownup \\\n    --pranalyzer \\\n    --nostdstats \\\n    --plot\n\n====================\n== Analyzers\n====================\n##########\nlegdownupanalyzer\n##########\nDate,LegDown,LegUp_5,LegUp_10,LegUp_15,LegUp_20\n2008-10-10,901.0,331.0,69.0,336.0,335.0\n2001-09-11,889.0,145.0,111.0,239.0,376.0\n2008-01-22,844.0,328.0,360.0,302.0,344.0\n2001-09-21,813.0,572.0,696.0,816.0,731.0\n2002-07-24,799.0,515.0,384.0,373.0,572.0\n2008-01-23,789.0,345.0,256.0,319.0,290.0\n2001-09-17,769.0,116.0,339.0,405.0,522.0\n2008-10-09,768.0,102.0,0.0,120.0,208.0\n2001-09-12,764.0,137.0,126.0,169.0,400.0\n2002-07-23,759.0,331.0,183.0,285.0,421.0\n2008-10-16,758.0,102.0,222.0,310.0,201.0\n2008-10-17,740.0,-48.0,219.0,218.0,116.0\n2015-08-24,731.0,nan,nan,nan,nan\n2002-07-22,729.0,292.0,62.0,262.0,368.0\n...\n...\n...\n2001-10-05,-364.0,228.0,143.0,286.0,230.0\n1999-01-04,-370.0,219.0,99.0,-7.0,191.0\n2000-03-06,-382.0,-60.0,-127.0,-39.0,-161.0\n2000-02-14,-393.0,-92.0,90.0,340.0,230.0\n2000-02-09,-400.0,-22.0,-46.0,96.0,270.0\n1999-01-05,-438.0,3.0,5.0,-107.0,5.0\n1999-01-07,-446.0,-196.0,-6.0,-82.0,-50.0\n1999-01-06,-536.0,-231.0,-42.0,-174.0,-129.0` \n```", "```py\n`from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport itertools\nimport operator\n\nimport six\nfrom six.moves import map, xrange, zip\n\nimport backtrader as bt\nimport backtrader.indicators as btind\nfrom backtrader.utils import OrderedDict\n\nclass LegDown(bt.Indicator):\n    '''\n    Calculates what the current legdown has been using:\n      - Current low\n      - High from ``period`` bars ago\n    '''\n    lines = ('legdown',)\n    params = (('period', 10),)\n\n    def __init__(self):\n        self.lines.legdown = self.data.high(-self.p.period) - self.data.low\n\nclass LegUp(bt.Indicator):\n    '''\n    Calculates what the current legup has been using:\n      - Current high\n      - Low from ``period`` bars ago\n\n    If param ``writeback`` is True the value will be written\n    backwards ``period`` bars ago\n    '''\n    lines = ('legup',)\n    params = (('period', 10), ('writeback', True),)\n\n    def __init__(self):\n        self.lu = self.data.high - self.data.low(-self.p.period)\n        self.lines.legup = self.lu(self.p.period * self.p.writeback)\n\nclass LegDownUpAnalyzer(bt.Analyzer):\n    params = (\n        # If created indicators have to be plotteda along the data\n        ('plotind', True),\n        # period to consider for a legdown\n        ('ldown', 10),\n        # periods for the following legups after a legdown\n        ('lups', [5, 10, 15, 20]),\n        # How to sort: date-asc, date-desc, legdown-asc, legdown-desc\n        ('sort', 'legdown-desc'),\n    )\n\n    sort_options = ['date-asc', 'date-des', 'legdown-desc', 'legdown-asc']\n\n    def __init__(self):\n        # Create the legdown indicator\n        self.ldown = LegDown(self.data, period=self.p.ldown)\n        self.ldown.plotinfo.plot = self.p.plotind\n\n        # Create the legup indicators indicator - writeback is not touched\n        # so the values will be written back the selected period and therefore\n        # be aligned with the end of the legdown\n        self.lups = list()\n        for lup in self.p.lups:\n            legup = LegUp(self.data, period=lup)\n            legup.plotinfo.plot = self.p.plotind\n            self.lups.append(legup)\n\n    def nextstart(self):\n        self.start = len(self.data) - 1\n\n    def stop(self):\n        # Calculate start and ending points with values\n        start = self.start\n        end = len(self.data)\n        size = end - start\n\n        # Prepare dates (key in the returned dictionary)\n        dtnumslice = self.strategy.data.datetime.getzero(start, size)\n        dtslice = map(lambda x: bt.num2date(x).date(), dtnumslice)\n        keys = dtslice\n\n        # Prepare the values, a list for each key item\n        # leg down\n        ldown = self.ldown.legdown.getzero(start, size)\n        # as many legs up as requested\n        lups = [up.legup.getzero(start, size) for up in self.lups]\n\n        # put legs down/up together and interleave (zip)\n        vals = [ldown] + lups\n        zvals = zip(*vals)\n\n        # Prepare sorting options\n        if self.p.sort == 'date-asc':\n            reverse, item = False, 0\n        elif self.p.sort == 'date-desc':\n            reverse, item = True, 0\n        elif self.p.sort == 'legdown-asc':\n            reverse, item = False, 1\n        elif self.p.sort == 'legdown-desc':\n            reverse, item = True, 1\n        else:\n            # Default ordering - date-asc\n            reverse, item = False, 0\n\n        # Prepare a sorted array of 2-tuples\n        keyvals_sorted = sorted(zip(keys, zvals),\n                                reverse=reverse,\n                                key=operator.itemgetter(item))\n\n        # Use it to build an ordereddict\n        self.ret = OrderedDict(keyvals_sorted)\n\n    def get_analysis(self):\n        return self.ret\n\n    def print(self, *args, **kwargs):\n        # Overriden to change default behavior (call pprint)\n        # provides a CSV printout of the legs down/up\n        header_items = ['Date', 'LegDown']\n        header_items.extend(['LegUp_%d' % x for x in self.p.lups])\n        header_txt = ','.join(header_items)\n        print(header_txt)\n\n        for key, vals in six.iteritems(self.ret):\n            keytxt = key.strftime('%Y-%m-%d')\n            txt = ','.join(itertools.chain([keytxt], map(str, vals)))\n            print(txt)` \n```"]