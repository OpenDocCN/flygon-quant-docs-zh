["```py\n`def _loadline(self, linetokens):\n\n  # parse the linetokens here and put them in self.lines.close,\n  # self.lines.high, etc\n\n  return True # if data was parsed, else ... return False` \n```", "```py\n`class DataBase(six.with_metaclass(MetaDataBase, dataseries.OHLCDateTime)):\n\n    params = (('dataname', None),\n        ('fromdate', datetime.datetime.min),\n        ('todate', datetime.datetime.max),\n        ('name', ''),\n        ('compression', 1),\n        ('timeframe', TimeFrame.Days),\n        ('sessionend', None))` \n```", "```py\n `def __init__(self):\n        super(VChartData, self).__init__()\n\n        # Use the informative \"timeframe\" parameter to understand if the\n        # code passed as \"dataname\" refers to an intraday or daily feed\n        if self.p.timeframe >= TimeFrame.Days:\n            self.barsize = 28\n            self.dtsize = 1\n            self.barfmt = 'IffffII'\n        else:\n            self.dtsize = 2\n            self.barsize = 32\n            self.barfmt = 'IIffffII'` \n```", "```py\n `def start(self):\n        # the feed must start ... get the file open (or see if it was open)\n        self.f = None\n        if hasattr(self.p.dataname, 'read'):\n            # A file has been passed in (ex: from a GUI)\n            self.f = self.p.dataname\n        else:\n            # Let an exception propagate\n            self.f = open(self.p.dataname, 'rb')` \n```", "```py\n `def stop(self):\n        # Close the file if any\n        if self.f is not None:\n            self.f.close()\n            self.f = None` \n```", "```py\n `def _load(self):\n        if self.f is None:\n            # if no file ... no parsing\n            return False\n\n        # Read the needed amount of binary data\n        bardata = self.f.read(self.barsize)\n        if not bardata:\n            # if no data was read ... game over say \"False\"\n            return False\n\n        # use struct to unpack the data\n        bdata = struct.unpack(self.barfmt, bardata)\n\n        # Years are stored as if they had 500 days\n        y, md = divmod(bdata[0], 500)\n        # Months are stored as if they had 32 days\n        m, d = divmod(md, 32)\n        # put y, m, d in a datetime\n        dt = datetime.datetime(y, m, d)\n\n        if self.dtsize > 1:  # Minute Bars\n            # Daily Time is stored in seconds\n            hhmm, ss = divmod(bdata[1], 60)\n            hh, mm = divmod(hhmm, 60)\n            # add the time to the existing atetime\n            dt = dt.replace(hour=hh, minute=mm, second=ss)\n\n        self.lines.datetime[0] = date2num(dt)\n\n        # Get the rest of the unpacked data\n        o, h, l, c, v, oi = bdata[self.dtsize:]\n        self.lines.open[0] = o\n        self.lines.high[0] = h\n        self.lines.low[0] = l\n        self.lines.close[0] = c\n        self.lines.volume[0] = v\n        self.lines.openinterest[0] = oi\n\n        # Say success\n        return True` \n```", "```py\n`from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport datetime\n\nimport backtrader as bt\nfrom vchart import VChartData\n\nif __name__ == '__main__':\n    # Create a cerebro entity\n    cerebro = bt.Cerebro(stdstats=False)\n\n    # Add a strategy\n    cerebro.addstrategy(bt.Strategy)\n\n    # Create a Data Feed\n    datapath = '../datas/goog.fd'\n    data = VChartData(\n        dataname=datapath,\n        fromdate=datetime.datetime(2006, 1, 1),\n        todate=datetime.datetime(2006, 12, 31),\n        timeframe=bt.TimeFrame.Days\n    )\n\n    # Add the Data Feed to Cerebro\n    cerebro.adddata(data)\n\n    # Run over everything\n    cerebro.run()\n\n    # Plot the result\n    cerebro.plot(style='bar')` \n```", "```py\n`from __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport datetime\nimport struct\n\nfrom backtrader.feed import DataBase\nfrom backtrader import date2num\nfrom backtrader import TimeFrame\n\nclass VChartData(DataBase):\n    def __init__(self):\n        super(VChartData, self).__init__()\n\n        # Use the informative \"timeframe\" parameter to understand if the\n        # code passed as \"dataname\" refers to an intraday or daily feed\n        if self.p.timeframe >= TimeFrame.Days:\n            self.barsize = 28\n            self.dtsize = 1\n            self.barfmt = 'IffffII'\n        else:\n            self.dtsize = 2\n            self.barsize = 32\n            self.barfmt = 'IIffffII'\n\n    def start(self):\n        # the feed must start ... get the file open (or see if it was open)\n        self.f = None\n        if hasattr(self.p.dataname, 'read'):\n            # A file has been passed in (ex: from a GUI)\n            self.f = self.p.dataname\n        else:\n            # Let an exception propagate\n            self.f = open(self.p.dataname, 'rb')\n\n    def stop(self):\n        # Close the file if any\n        if self.f is not None:\n            self.f.close()\n            self.f = None\n\n    def _load(self):\n        if self.f is None:\n            # if no file ... no parsing\n            return False\n\n        # Read the needed amount of binary data\n        bardata = self.f.read(self.barsize)\n        if not bardata:\n            # if no data was read ... game over say \"False\"\n            return False\n\n        # use struct to unpack the data\n        bdata = struct.unpack(self.barfmt, bardata)\n\n        # Years are stored as if they had 500 days\n        y, md = divmod(bdata[0], 500)\n        # Months are stored as if they had 32 days\n        m, d = divmod(md, 32)\n        # put y, m, d in a datetime\n        dt = datetime.datetime(y, m, d)\n\n        if self.dtsize > 1:  # Minute Bars\n            # Daily Time is stored in seconds\n            hhmm, ss = divmod(bdata[1], 60)\n            hh, mm = divmod(hhmm, 60)\n            # add the time to the existing atetime\n            dt = dt.replace(hour=hh, minute=mm, second=ss)\n\n        self.lines.datetime[0] = date2num(dt)\n\n        # Get the rest of the unpacked data\n        o, h, l, c, v, oi = bdata[self.dtsize:]\n        self.lines.open[0] = o\n        self.lines.high[0] = h\n        self.lines.low[0] = l\n        self.lines.close[0] = c\n        self.lines.volume[0] = v\n        self.lines.openinterest[0] = oi\n\n        # Say success\n        return True` \n```"]